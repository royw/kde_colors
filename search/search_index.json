{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KDE Colors","text":"<p>A CLI tool that extracts color schemes from KDE themes</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Project Overview - Features and usage</li> <li>User Guide - Detailed usage instructions for the CLI</li> <li>Developer Guide - Setup and contribution</li> <li>Architecture - System design and component relationships</li> <li>Theme Files - Information about KDE theme file formats and locations</li> <li>Color Files - Details about color formats and specifications</li> <li>API Reference - Module and class documentation</li> </ul>"},{"location":"#project-information","title":"Project Information","text":"<ul> <li>License - License information</li> </ul> <p>*Last updated:  2025-06-24 *</p> <p>Built with MkDocs and Material for MkDocs.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>This document describes the high-level architecture of the <code>kde-colors</code> project.</p>"},{"location":"architecture/#package-structure","title":"Package Structure","text":"<p>The <code>kde_colors</code> package is organized into the following structure:</p> <pre><code>kde_colors/\n\u251c\u2500\u2500 __init__.py        # Main package initialization\n\u251c\u2500\u2500 __main__.py        # Entry point for direct execution, defined in pyproject.toml, calls cli_runner.run_cli()\n\u251c\u2500\u2500 cli/               # Command-line interface components\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 cli_arg_parser.py  # Argument parsing\n\u2502   \u2514\u2500\u2500 cli_runner.py      # Command execution\n\u251c\u2500\u2500 interfaces/        # Protocol definitions\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 environment.py     # Environment interface\n\u2502   \u251c\u2500\u2500 file_system.py     # FileSystem interface\n\u2502   \u251c\u2500\u2500 output_formatter.py # OutputFormatter interface\n\u2502   \u251c\u2500\u2500 theme_loader.py    # ThemeLoader interface\n\u2502   \u2514\u2500\u2500 xdg.py            # XDG interface\n\u251c\u2500\u2500 services/          # Service implementations\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 environment.py     # Environment service\n\u2502   \u251c\u2500\u2500 file_system.py     # FileSystem implementation\n\u2502   \u251c\u2500\u2500 output_formatter.py # OutputFormatter implementation\n\u2502   \u251c\u2500\u2500 theme_loader.py    # ThemeLoader implementation\n\u2502   \u2514\u2500\u2500 xdg.py             # XDG implementation\n\u2514\u2500\u2500 tests/             # Test suite\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 unit/               # Unit tests\n    \u2502   \u2514\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 integration/        # Integration tests\n    \u2502   \u2514\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 e2e/                # End-to-end tests\n    \u2502   \u2514\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 performance/        # Performance tests\n    \u2502   \u2514\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 support/           # Test doubles for interfaces\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 environment_double.py\n        \u251c\u2500\u2500 file_system_double.py\n        \u251c\u2500\u2500 output_formatter_double.py\n        \u251c\u2500\u2500 theme_loader_double.py\n        \u2514\u2500\u2500 xdg_double.py\n</code></pre>"},{"location":"architecture/#project-script","title":"Project Script","text":"<p>The <code>kde-colors</code> script is the entry point for the application. It is defined in the <code>kde_colors.__main__</code> module.</p> <p>pyproject.toml defines the script entry point: scripts = {'kde_colors' = \"kde_colors.main:main\"}</p>"},{"location":"architecture/#system-overview","title":"System Overview","text":"<p>The following diagram shows the main components of the system and their relationships:</p> <pre><code>graph TD\n    %% Core Components\n    User[User] --&gt;|interacts with| CLI[\"CLI (Command Line Interface)\"]\n    CLI --&gt;|uses| CLIRunner[\"CLIRunner\"]\n\n    %% Command Handlers\n    CLIRunner --&gt;|dispatches to| CommandHandlers[\"Command Handlers\"]\n    CommandHandlers --&gt;|list command| ListCmd[\"List Command\"]\n    CommandHandlers --&gt;|paths command| PathsCmd[\"Paths Command\"]\n    CommandHandlers --&gt;|theme command| ThemeCmd[\"Theme Command\"]\n\n    %% Services\n    ListCmd --&gt;|uses| ThemeLoader[\"ThemeLoader\"]\n    PathsCmd --&gt;|uses| ThemeLoader\n    ThemeCmd --&gt;|uses| ThemeLoader\n\n    %% Formatters\n    ListCmd --&gt;|formats output via| OutputFormatter[\"OutputFormatter\"]\n    PathsCmd --&gt;|formats output via| OutputFormatter\n    ThemeCmd --&gt;|formats output via| OutputFormatter\n\n    %% Output Formatter Types\n    OutputFormatter --&gt;|creates| TextOut[\"*TextOutputFormatter\"]\n    OutputFormatter --&gt;|creates| JsonOut[\"*JsonOutputFormatter\"]\n\n    %% Note for formatter types\n    JsonOut -.- Note(\"<p>* is one of <ul><li>List</li><li>Paths</li><li>Theme</li></ul></p>\")\n    TextOut -.- Note\n\n    %% Dependencies\n    ThemeLoader --&gt;|depends on| FileSystem[\"FileSystem\"]\n    ThemeLoader --&gt;|depends on| XDG[\"XDG\"]\n    FileSystem --&gt;|depends on| Environment[\"Environment\"]\n    XDG --&gt;|depends on| Environment\n\n    %% Interface Implementation Relationships\n    ThemeLoader -.-&gt;|implements| ThemeLoaderInterface[\"ThemeLoaderInterface\"]\n    FileSystem -.-&gt;|implements| FileSystemInterface[\"FileSystemInterface\"]\n    OutputFormatter -.-&gt;|implements| OutputFormatterInterface[\"OutputFormatterInterface\"]\n    Environment -.-&gt;|implements| EnvironmentInterface[\"EnvironmentInterface\"]\n    XDG -.-&gt;|implements| XDGInterface[\"XDGInterface\"]\n\n    class ThemeLoaderInterface,FileSystemInterface,OutputFormatterInterface,EnvironmentInterface,XDGInterface interface\n    class ThemeLoader,FileSystem,OutputFormatter,Environment,XDG service\n    class CLI,CLIRunner,CommandHandlers,ListCmd,PathsCmd,ThemeCmd cli\n    class User user\n</code></pre> <p>This architecture follows a clean, dependency-injected design with clear separation of interfaces and implementations. The CLI layer handles user interaction, the service layer provides core functionality, and interfaces establish contracts between components.</p>"},{"location":"architecture/#interface-design","title":"Interface Design","text":"<p>The system uses protocol-based interfaces to define clear contracts between components. The main interfaces are defined in the <code>kde_colors.interfaces</code> package:</p>"},{"location":"architecture/#filesysteminterface","title":"FileSystemInterface","text":"<ul> <li>Purpose: Abstract file system operations for both reading and writing.</li> <li>Location: <code>kde_colors.interfaces.file_system</code></li> <li>Key Methods: <code>read_text()</code>, <code>exists()</code>, <code>is_file()</code>, <code>is_dir()</code>, <code>glob()</code>, <code>walk()</code>, <code>resolve_path()</code>, <code>expand_path()</code>, <code>list_files()</code>, <code>list_dir()</code>, <code>write_text()</code></li> </ul>"},{"location":"architecture/#testssupportfile_system_doublepy","title":"tests/support/file_system_double.py","text":"<ul> <li>Implements: Implements the <code>FileSystemInterface</code> protocol</li> <li>Purpose: Test double implementation of the FileSystem interface for testing.</li> <li>Location: <code>tests.support.file_system_double</code></li> <li>Key Methods: All methods from <code>FileSystemInterface</code> plus additional testing functionality like <code>mkdir()</code>, <code>remove()</code>, <code>rmdir()</code></li> </ul>"},{"location":"architecture/#xdginterface","title":"XDGInterface","text":"<ul> <li>Purpose: Abstract XDG Base Directory Specification that encapsulates XDG directory paths. Allows tests to inject custom XDG directories.</li> <li>Location: <code>kde_colors.interfaces.xdg</code></li> <li>Key Methods: <code>xdg_cache_home()</code>, <code>xdg_config_dirs()</code>, <code>xdg_config_home()</code>, <code>xdg_data_dirs()</code>, <code>xdg_data_home()</code>, <code>xdg_runtime_dir()</code>, <code>xdg_state_home()</code></li> </ul>"},{"location":"architecture/#testssupportxdg_doublepy","title":"tests/support/xdg_double.py","text":"<ul> <li>Implements: Implements the <code>XDGInterface</code> protocol</li> <li>Purpose: Test double implementation for XDG interface</li> <li>Location: <code>tests.support.xdg_double</code></li> <li>Key Methods: All methods from <code>XDGInterface</code> with customizable directory configurations</li> </ul>"},{"location":"architecture/#themeloaderinterface","title":"ThemeLoaderInterface","text":"<ul> <li>Purpose: Load and query KDE themes using XDG and FileSystem interfaces.</li> <li>Location: <code>kde_colors.interfaces.theme_loader</code></li> <li>Key Methods: <code>get_themes()</code>, <code>get_theme_paths()</code>, <code>get_current_theme()</code>, <code>get_theme_details()</code></li> </ul>"},{"location":"architecture/#testssupporttheme_loader_doublepy","title":"tests/support/theme_loader_double.py","text":"<ul> <li>Implements: Implements the <code>ThemeLoaderInterface</code> protocol</li> <li>Purpose: Test double implementation for the ThemeLoader interface</li> <li>Location: <code>tests.support.theme_loader_double</code></li> <li>Key Methods: All methods from <code>ThemeLoaderInterface</code> with predefined test data</li> </ul>"},{"location":"architecture/#outputformatterinterface","title":"OutputFormatterInterface","text":"<ul> <li>Purpose: Format theme data into different output formats</li> <li>Location: <code>kde_colors.interfaces.output_formatter</code></li> <li>Key Method: <code>format()</code></li> </ul>"},{"location":"architecture/#testssupportoutput_formatter_doublepy","title":"tests/support/output_formatter_double.py","text":"<ul> <li>Implements: Implements the <code>OutputFormatterInterface</code> protocol</li> <li>Purpose: Test double implementation for the OutputFormatter interface</li> <li>Location: <code>tests.support.output_formatter_double</code></li> <li>Key Method: <code>format()</code> with configurable output</li> </ul>"},{"location":"architecture/#environmentinterface","title":"EnvironmentInterface","text":"<ul> <li>Purpose: Abstract interface that encapsulates environment variables. Allows tests to inject custom environment variables.</li> <li>Location: <code>kde_colors.interfaces.environment</code></li> <li>Key Methods: <code>getenv()</code></li> </ul>"},{"location":"architecture/#testssupportenvironment_doublepy","title":"tests/support/environment_double.py","text":"<ul> <li>Implements: Implements the <code>EnvironmentInterface</code> protocol</li> <li>Purpose: Test double implementation for the Environment interface</li> <li>Location: <code>tests.support.environment_double</code></li> <li>Key Methods: <code>getenv()</code>, <code>setenv()</code>, <code>clearenv()</code></li> </ul>"},{"location":"architecture/#services","title":"Services","text":"<ul> <li>Purpose: Implement protocol interfaces.</li> <li>Location: <code>kde_colors.services</code></li> <li>Key Classes: <code>ThemeLoader</code>, <code>FileSystem</code>, <code>OutputFormatter</code>, <code>EnvironmentService</code></li> </ul>"},{"location":"architecture/#themeloader-service","title":"ThemeLoader Service","text":"<ul> <li>Purpose: Load and query KDE themes using XDG and FileSystem Interfaces.</li> <li>Location: <code>kde_colors.services.theme_loader</code></li> <li>Key Methods: <code>load_themes()</code></li> </ul>"},{"location":"architecture/#filesystem-service","title":"FileSystem Service","text":"<ul> <li>Purpose: Abstract Read-only file system operations injector.</li> <li>Location: <code>kde_colors.services.file_system</code></li> <li>Key Methods: <code>read_file()</code>, <code>file_exists()</code>, <code>exists()</code>, <code>is_file()</code>, <code>is_dir()</code>, <code>glob()</code>, <code>walk()</code>, <code>resolve_path()</code>, <code>expand_path()</code>, <code>list_files()</code>, <code>list_dir()</code></li> </ul>"},{"location":"architecture/#outputformatter-service","title":"OutputFormatter Service","text":"<ul> <li>Purpose: Format theme data into different output formats</li> <li>Location: <code>kde_colors.services.output_formatter</code></li> <li>Key Method: <code>format()</code></li> </ul>"},{"location":"architecture/#environment-service","title":"Environment Service","text":"<ul> <li>Purpose: Abstract environment detection injector that encapsulates environment variables.  Allows tests to inject custom environment variables.</li> <li>Location: <code>kde_colors.services.environment</code></li> <li>Key Methods: <code>getenv()</code></li> </ul>"},{"location":"architecture/#theme-data-structure","title":"Theme Data Structure","text":"<p>Theme data is represented as dictionaries in the application:</p> <ul> <li>Theme metadata: <code>dict[str, str]</code> - Contains name, package, etc.</li> <li>Theme colors: <code>dict[str, dict[str, list[int]]]</code> - Color definitions organized by color group</li> <li>Theme paths: <code>list[str]</code> - Lists of paths to theme files</li> </ul>"},{"location":"architecture/#testing-architecture","title":"Testing Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>The KDE Colors project follows a strict set of testing principles designed to ensure high code quality, reliability, and maintainability. The key aspects of the testing architecture include:</p> <ul> <li>No Mocking: All forms of mocking, patching, and monkeypatching are explicitly forbidden. This ensures tests are resilient to implementation changes.</li> <li>Test Doubles: Instead of mocks, the project uses test doubles that implement the same interfaces as the production code.</li> <li>Test Organization: Tests are organized by type (unit, integration, e2e) and follow a consistent structure.</li> <li>High Coverage: The project aims for high test coverage (minimum 80%) to ensure reliability.</li> </ul>"},{"location":"architecture/#test-directory-structure","title":"Test Directory Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 unit/             # Unit tests for individual components\n\u2502   \u251c\u2500\u2500 interfaces/   # Tests for interface implementations\n\u2502   \u251c\u2500\u2500 services/     # Tests for service implementations\n\u2502   \u2514\u2500\u2500 cli/          # Tests for CLI components\n\u251c\u2500\u2500 integration/      # Integration tests for combinations of components\n\u251c\u2500\u2500 e2e/              # End-to-end tests for full user workflows\n\u2514\u2500\u2500 support/          # Test doubles and utilities used across tests\n    \u251c\u2500\u2500 environment_double.py\n    \u251c\u2500\u2500 file_system_double.py\n    \u251c\u2500\u2500 output_formatter_double.py\n    \u251c\u2500\u2500 theme_loader_double.py\n    \u2514\u2500\u2500 xdg_double.py\n</code></pre>"},{"location":"architecture/#test-types","title":"Test Types","text":"<p>Tests are organized into different categories based on their scope and purpose:</p> <pre><code>graph TD\n    %% Test Types\n    subgraph \"Test Types\"\n        UnitTests[\"<p>Unit Tests</p><p>Test individual components in isolation</p>\"]\n        IntegrationTests[\"<p>Integration Tests</p><p>Test component interactions</p>\"]\n        E2ETests[\"<p>End-to-End Tests</p><p>Test complete user workflows</p>\"]\n    end\n\n    UnitTests --&gt;|verify| Components[\"<p>Individual components</p>\"]\n    IntegrationTests --&gt;|verify| Interactions[\"<p>Component interactions</p>\"]\n    E2ETests --&gt;|verify| Workflows[\"<p>End-to-end workflows</p>\"]\n\n    class UnitTests,IntegrationTests,E2ETests testType\n    class Components,Interactions,Workflows testTarget\n</code></pre>"},{"location":"architecture/#test-doubles","title":"Test Doubles","text":"<p>Instead of using mocks, the project employs test doubles that implement the same interface protocols as production code. This approach ensures tests remain valid even when implementation details change, as long as the interface remains consistent.</p> <pre><code>graph TD\n    %% Interfaces\n    FileSystemInterface[\"FileSystemInterface\"] &lt;-..- FileSystemDouble[\"FileSystemDouble\"]\n    EnvironmentInterface[\"EnvironmentInterface\"] &lt;-..- EnvironmentDouble[\"EnvironmentDouble\"]\n    XDGInterface[\"XDGInterface\"] &lt;-..- XDGDouble[\"XDGDouble\"]\n    ThemeLoaderInterface[\"ThemeLoaderInterface\"] &lt;-..- ThemeLoaderDouble[\"ThemeLoaderDouble\"]\n    OutputFormatterInterface[\"OutputFormatterInterface\"] &lt;-..- OutputFormatterDouble[\"OutputFormatterDouble\"]\n\n    %% Test Descriptions\n    FileSystemDouble -.-&gt; FileSystemTest[\"<p>In-memory file system simulation with configurable behavior</p>\"]\n    EnvironmentDouble -.-&gt; EnvironmentTest[\"<p>Controllable environment variables for testing</p>\"]\n    XDGDouble -.-&gt; XDGTest[\"<p>Custom XDG paths for test isolation</p>\"]\n    ThemeLoaderDouble -.-&gt; ThemeLoaderTest[\"<p>Pre-configured theme data for predictable testing</p>\"]\n    OutputFormatterDouble -.-&gt; OutputFormatterTest[\"<p>Simplified output for easy verification</p>\"]\n\n    class FileSystemInterface,EnvironmentInterface,XDGInterface,ThemeLoaderInterface,OutputFormatterInterface interface\n    class FileSystemDouble,EnvironmentDouble,XDGDouble,ThemeLoaderDouble,OutputFormatterDouble testDouble\n    class FileSystemTest,EnvironmentTest,XDGTest,ThemeLoaderTest,OutputFormatterTest testDesc\n</code></pre>"},{"location":"architecture/#testing-patterns","title":"Testing Patterns","text":""},{"location":"architecture/#dependency-injection","title":"Dependency Injection","text":"<p>All tests leverage dependency injection to substitute test doubles for real implementations. This allows tests to control the environment and isolate the component being tested.</p> <pre><code># Example: Testing with dependency injection\ndef test_theme_loader_gets_themes(file_system_double, xdg_double):\n    # Arrange\n    theme_loader = ThemeLoader(file_system=file_system_double, xdg=xdg_double)\n\n    # Act\n    themes = theme_loader.get_themes()\n\n    # Assert\n    assert len(themes) &gt; 0\n</code></pre>"},{"location":"architecture/#arrange-act-assert","title":"Arrange-Act-Assert","text":"<p>Tests follow the Arrange-Act-Assert pattern to clearly separate the setup, execution, and verification phases of each test.</p>"},{"location":"architecture/#test-doubles-configuration","title":"Test Doubles Configuration","text":"<p>Test doubles are designed to be easily configured for specific test scenarios:</p> <pre><code># Example: Configuring a test double\ndef test_file_system_operations(file_system_double):\n    # Arrange - configure the test double\n    file_system_double.write_text(\"/path/to/file.txt\", \"test content\")\n\n    # Act\n    exists = file_system_double.exists(\"/path/to/file.txt\")\n    content = file_system_double.read_text(\"/path/to/file.txt\")\n\n    # Assert\n    assert exists is True\n    assert content == \"test content\"\n</code></pre>"},{"location":"architecture/#integration-testing","title":"Integration Testing","text":"<p>Integration tests verify that components work correctly together. They typically use the same test doubles as unit tests but focus on the interaction between multiple components.</p> <pre><code># Example: Integration test\ndef test_cli_list_command_with_theme_loader(file_system_double, xdg_double):\n    # Arrange - setup the test environment\n    theme_loader = ThemeLoader(file_system=file_system_double, xdg=xdg_double)\n    cli_runner = CLIRunner(theme_loader=theme_loader)\n\n    # Configure test doubles with test data\n    file_system_double.write_text(\"/themes/theme1.colors\", \"[General]\\nName=Theme1\")\n\n    # Act - run the CLI command\n    result = cli_runner.run([\"list\", \"--json\"])\n\n    # Assert - verify the output\n    assert \"Theme1\" in result\n</code></pre>"},{"location":"architecture/#end-to-end-testing","title":"End-to-End Testing","text":"<p>E2E tests verify complete user workflows by testing the application from the CLI entry point to the output, ensuring that all components work together correctly.</p> <pre><code># Example: End-to-End test\n@pytest.mark.usefixtures(\"kde_home\")\ndef test_list_text_output(run_cli: CallableABC[[list[str], Path | None], tuple[int, str, str]]) -&gt; None:\n    \"\"\"Test the list command with default text output.\"\"\"\n    # Run the CLI command from the temporary environment\n    # kde_home is used by the fixture to set up the environment\n    exit_code, stdout, stderr = run_cli([\"list\"], None)\n\n    # Check that the command succeeded\n    assert exit_code == 0, f\"Command failed with stderr: {stderr}\"\n\n    # Verify output contains expected themes\n    assert \"Available desktop themes\" in stdout\n    assert \"Alfa\" in stdout\n    assert \"Bravo\" in stdout\n    assert \"Charlie\" in stdout\n    assert \"Delta\" in stdout\n</code></pre> <p>This example demonstrates how E2E tests use the actual CLI entry point (<code>run_cli</code>). The test verifies that the command produces the expected output format and content.</p>"},{"location":"architecture/#cli-package-architecture","title":"CLI Package Architecture","text":"<p>The CLI module follows a structured architecture for handling commands and formatting output:</p>"},{"location":"architecture/#cli_arg_parserpy","title":"cli_arg_parser.py","text":"<ul> <li>Purpose: Defines and handles command-line argument parsing</li> <li>Key Components:</li> <li><code>create_parser()</code>: Creates and configures the command-line argument parser</li> <li><code>parse_args()</code>: Parses command-line arguments and applies defaults</li> <li><code>get_version()</code>: Retrieves the application version</li> </ul>"},{"location":"architecture/#cli_runnerpy","title":"cli_runner.py","text":"<ul> <li>Purpose: Executes CLI commands based on parsed arguments</li> <li>Key Components:</li> <li><code>CLIRunner</code> class: Orchestrates the execution of commands</li> <li>Command handlers: <code>_cmd_list()</code>, <code>_cmd_paths()</code>, <code>_cmd_theme()</code></li> <li><code>run_cli()</code>: Entry point function for the application</li> </ul>"},{"location":"architecture/#command-line-argument-parsing","title":"Command-line Argument Parsing","text":"<p>The CLI argument parsing architecture uses the sub-parser pattern from Python's <code>argparse</code> module:</p> <pre><code>graph TD\n    %% CLI Argument Parsing Architecture\n    main_parser[Main Parser]--&gt;parent_parser[Parent Parser with Global Options]\n    main_parser--&gt;subparsers[Subparsers]\n\n    subparsers--&gt;list_cmd[List Command]\n    subparsers--&gt;paths_cmd[Paths Command]\n    subparsers--&gt;theme_cmd[Theme Command]\n\n    parent_parser-.-&gt;|inherits|list_cmd\n    parent_parser-.-&gt;|inherits|paths_cmd\n    parent_parser-.-&gt;|inherits|theme_cmd\n\n    %% Options flow\n    list_cmd--&gt;parsed_args[Parsed Arguments]\n    paths_cmd--&gt;parsed_args\n    theme_cmd--&gt;parsed_args\n    parsed_args--&gt;command_handler[Command Handler]\n</code></pre> <p>This architecture has several benefits:</p> <ol> <li>Consistent Option Handling: Global options like <code>--verbose</code> are defined once but work universally</li> <li>Modular Design: Each command is encapsulated in its own parser</li> <li>Extensible: Adding new commands requires minimal changes to existing code</li> <li>Uniform Help Text: Help documentation is standardized across all commands</li> </ol>"},{"location":"architecture/#version-management","title":"Version Management","text":"<p>Version information is managed through Python's standard library:</p> <pre><code>graph LR\n    %% Version Management Architecture\n    pyproject[pyproject.toml]--&gt;|defines|package_version[Package Version]\n    package_version--&gt;|read by|importlib[importlib.metadata]\n    importlib--&gt;|provides|version_var[__version__ Variable]\n    version_var--&gt;|used by|cli[CLI --version Flag]\n    version_var--&gt;|used by|error_reporting[Error Reporting]\n</code></pre> <p>This approach follows Python's best practices:</p> <ol> <li>The version is defined exactly once in the project metadata</li> <li>Runtime version detection uses the standard library's <code>importlib.metadata</code></li> <li>No hardcoded version strings throughout the codebase</li> </ol>"},{"location":"architecture/#components","title":"Components","text":""},{"location":"architecture/#cli","title":"CLI","text":"<p>The Command Line Interface (CLI) is the main entry point for users. It handles:</p> <ul> <li>Command-line argument parsing</li> <li>User input validation</li> <li>Coordinating between different components</li> </ul>"},{"location":"architecture/#core-services","title":"Core Services","text":""},{"location":"architecture/#themeloader","title":"ThemeLoader","text":"<p>The ThemeLoader component is responsible for:</p> <ul> <li>Loading theme data from KDE configuration files</li> <li>Validating theme data</li> <li>Providing a clean interface for accessing theme properties</li> </ul>"},{"location":"architecture/#filesystem","title":"FileSystem","text":"<p>The FileSystem component handles all file system operations:</p> <ul> <li>Enables test doubling by routing file system operations to a protocol interface</li> <li>Provides a clean interface for accessing file system properties</li> <li>Handles file system errors</li> </ul>"},{"location":"architecture/#output-formatters","title":"Output Formatters","text":"<p>Output formatters convert theme data into different formats:</p> <ul> <li>JSON</li> <li>Human-readable text</li> <li>Potentially other formats in the future</li> </ul>"},{"location":"color-files/","title":"KDE Theme Color Files","text":"<p>This document describes how color files are located and processed in the KDE Theme Colors project.</p>"},{"location":"color-files/#color-file-locations","title":"Color File Locations","text":"<p>KDE Theme Colors looks for color scheme files in several locations, checked in the following order:</p> <ol> <li>Named Color Scheme File: If a theme specifies a color scheme name, it will check for <code>colors/{scheme_name}.colors</code> in the theme directory.</li> <li>Root Colors File: A file named <code>colors</code> in the root of the theme directory.</li> <li>Nested Colors File: A file named <code>colors</code> in the <code>colors/</code> subdirectory of the theme directory (<code>colors/colors</code>).</li> <li>Theme Metadata: As a fallback, colors may be extracted from the theme's metadata.</li> </ol>"},{"location":"color-files/#color-file-format","title":"Color File Format","text":"<p>KDE color scheme files use an INI-like format with sections and key-value pairs:</p> <pre><code>[Colors:View]\nBackgroundNormal=20,22,24\nForegroundNormal=239,240,241\n\n[Colors:Window]\nBackgroundNormal=49,54,59\nForegroundNormal=239,240,241\n\n[General]\nColorScheme=ThemeName\n</code></pre>"},{"location":"color-files/#sections-and-keys","title":"Sections and Keys","text":"<ul> <li>Sections are defined by square brackets <code>[Section Name]</code></li> <li>Each section contains key-value pairs separated by <code>=</code></li> <li>Color values are typically represented as comma-separated RGB values (0-255)</li> <li>The <code>[General]</code> section may contain a <code>ColorScheme</code> key that specifies the name of the color scheme</li> </ul>"},{"location":"color-files/#comments-and-whitespace","title":"Comments and Whitespace","text":"<ul> <li>Lines beginning with <code>#</code> are treated as comments and ignored</li> <li>Inline comments (starting with <code>#</code>) after a value are also supported</li> <li>Empty lines and extra whitespace are ignored</li> <li>Leading and trailing whitespace around keys and values is trimmed</li> </ul>"},{"location":"color-files/#case-sensitivity","title":"Case Sensitivity","text":"<ul> <li>Section names are treated as case-sensitive (e.g., <code>[Colors:View]</code> vs <code>[colors:view]</code>)</li> <li>Keys are treated as case-insensitive (e.g., <code>BackgroundNormal</code> is equivalent to <code>backgroundnormal</code>)</li> <li>This is due to the use of <code>configparser</code> which lowercases keys but preserves section names</li> </ul>"},{"location":"color-files/#processing-of-color-files","title":"Processing of Color Files","text":"<ol> <li>The loader attempts to read a color file from one of the locations listed above</li> <li>The file is parsed using Python's <code>configparser</code> module</li> <li>Sections and keys are extracted and organized into a structured dictionary</li> <li>The color scheme name is extracted from the <code>[General]</code> section if available</li> <li>The parsed colors are added to the theme's color dictionary</li> <li>If a color scheme name is found in the file, it is set as the theme's <code>color_scheme</code> property</li> </ol>"},{"location":"color-files/#error-handling","title":"Error Handling","text":"<ul> <li>If a color file is missing or unreadable, the loader tries the next location</li> <li>If a color file is malformed, it is skipped with a warning</li> <li>If no colors are found in any location, the theme's colors remain empty</li> <li>Debug logging provides detailed information about the color loading process</li> </ul>"},{"location":"color-files/#testing-with-color-files","title":"Testing with Color Files","text":"<p>When creating test cases for color loading:</p> <ul> <li>Ensure test color files follow the format described above</li> <li>Remember that keys will be lowercased by the parser, so use case-insensitive checks in tests</li> <li>Use the test doubles (<code>FakeFileSystem</code> and <code>FakeFileHandle</code>) for file operations</li> <li>For integration tests, place real color files in the appropriate test directories</li> </ul>"},{"location":"license/","title":"MIT License","text":"<p>Copyright (c) 2025 Roy Wright</p> <pre><code>Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre> <p>This is a human-readable summary of the full license.</p>"},{"location":"theme-files/","title":"KDE Theme Files","text":"<p>This document provides an overview of KDE theme files, their locations, and how the <code>kde-colors</code> tool locates and processes them.</p>"},{"location":"theme-files/#freedesktoporg-compliance","title":"freedesktop.org Compliance","text":"<p>Except from https://userbase.kde.org/KDE_System_Administration/Environment_Variables</p> <p>The following environment variables are defined in the freedesktop.org base directory specification and are supported by all XDG-compliant environments and applications, such as KDE.</p>"},{"location":"theme-files/#xdg_data_home","title":"XDG_DATA_HOME","text":"<p>Defines the base directory relative to which user specific data files should be stored. If $XDG_DATA_HOME is either not set or empty, a default equal to $HOME/.local/share is used.</p>"},{"location":"theme-files/#xdg_config_home","title":"XDG_CONFIG_HOME","text":"<p>Defines the base directory relative to which user specific configuration files should be stored. If $XDG_CONFIG_HOME is either not set or empty, a default equal to $HOME/.config is used.</p>"},{"location":"theme-files/#xdg_data_dirs","title":"XDG_DATA_DIRS","text":"<p>Defines the preference-ordered set of base directories to search for data files in addition to the $XDG_DATA_HOME base directory. The directories in $XDG_DATA_DIRS should be separated with a colon ':'. If $XDG_DATA_DIRS is either not set or empty, a value equal to /usr/local/share/:/usr/share/ is used.</p>"},{"location":"theme-files/#xdg_config_dirs","title":"XDG_CONFIG_DIRS","text":"<p>Defines the preference-ordered set of base directories to search for configuration files in addition to the $XDG_CONFIG_HOME base directory. The directories in $XDG_CONFIG_DIRS should be separated with a colon ':'. If $XDG_CONFIG_DIRS is either not set or empty, a value equal to /etc/xdg is used.</p>"},{"location":"theme-files/#current-theme-configuration-locations","title":"Current Theme Configuration Locations","text":"<p>The currently active KDE theme is determined by checking several configuration files, in the following order of precedence:</p> <ol> <li><code>$XDG_CONFIG_HOME/kdedefaults/package</code> - Contains the theme name directly (e.g., <code>org.kde.breezedark.desktop</code>).</li> <li><code>$XDG_CONFIG_HOME/kdedefaults/kdeglobals</code> - Contains theme information in the following keys:</li> <li><code>Theme=breeze-dark</code> - Theme name in the desktoptheme directory</li> <li><code>ColorScheme=BreezeDark</code> - Associated color scheme name</li> <li><code>$XDG_CONFIG_HOME/kdeglobals</code> - Contains the following key:</li> <li><code>LookAndFeelPackage=org.kde.breezedark.desktop</code> - Theme package name</li> <li><code>$XDG_CONFIG_HOME/plasmarc</code> - Contains theme information in the <code>[Theme]</code> section:</li> <li><code>name=breeze-dark</code> - Theme name</li> </ol> <p>Example configuration of Breeze Dark theme:</p> <pre><code>/home/user/.config/kdedefaults/kdeglobals:Theme=breeze-dark\n/home/user/.config/kdedefaults/kdeglobals:ColorScheme=BreezeDark\n/home/user/.config/kdedefaults/package:org.kde.breezedark.desktop\n/home/user/.config/kdeglobals:LookAndFeelPackage=org.kde.breezedark.desktop\n</code></pre> <p>Example configuration of Breeze Light theme:</p> <pre><code>/home/user/.config/kdedefaults/kdeglobals:Theme=breeze\n/home/user/.config/kdedefaults/package:org.kde.breeze.desktop\n/home/user/.config/kdedefaults/kdeglobals:ColorScheme=BreezeLight\n/home/user/.config/kdeglobals:LookAndFeelPackage=org.kde.breeze.desktop\n</code></pre>"},{"location":"theme-files/#theme-directory-structure","title":"Theme Directory Structure","text":"<p>A valid KDE theme directory typically contains the following elements:</p> <p>theme-name/</p> <ul> <li>metadata.desktop or metadata.json</li> <li>colors/ or colors or *.colors</li> </ul>"},{"location":"theme-files/#theme-identification","title":"Theme Identification","text":"<p>A directory is identified as a valid theme if it contains at least one of the following:</p> <ol> <li>A valid metadata file:</li> <li><code>metadata.desktop</code> with <code>Type=Theme</code> or a Look and Feel section</li> <li> <p><code>metadata.json</code> with theme information</p> </li> <li> <p>Color scheme files:</p> </li> <li><code>*.colors</code> files in the root directory</li> <li><code>colors/*.colors</code> files in a subdirectory</li> <li>A <code>colors</code> file with color scheme content</li> </ol>"},{"location":"theme-files/#theme-metadata","title":"Theme Metadata","text":"<p>Theme metadata is extracted from either <code>metadata.desktop</code> or <code>metadata.json</code> files, with <code>metadata.json</code> taking precedence when both files exist. The following information is typically included:</p> <ul> <li>Theme name</li> <li>Display name</li> <li>Description</li> <li>Author</li> <li>Version</li> </ul>"},{"location":"theme-files/#metadatadesktop-format","title":"metadata.desktop Format","text":"<p>The <code>metadata.desktop</code> file uses a standard INI-like format and includes sections like:</p> <pre><code>[Desktop Entry]\nName=Theme Name\nComment=Theme description\n\n[KDE]\nDefaultTheme=breeze\n\n[X-KDE-PluginInfo]\nAuthor=Theme Author\nVersion=1.0\n</code></pre>"},{"location":"theme-files/#metadatajson-format","title":"metadata.json Format","text":"<p>The <code>metadata.json</code> file uses JSON format with a primary <code>KPlugin</code> section that contains key theme information:</p> <pre><code>{\n  \"KPlugin\": {\n    \"Id\": \"breeze-dark\",\n    \"Name\": \"Breeze Dark\",\n    \"Description\": \"A dark theme for KDE\",\n    \"Author\": \"KDE Visual Design Group\",\n    \"Version\": \"1.0\"\n  }\n}\n</code></pre>"},{"location":"theme-files/#key-fields","title":"Key Fields","text":"<ul> <li>KPlugin.Id: The theme's internal identifier (e.g., \"breeze-dark\")</li> <li>KPlugin.Name: The human-readable display name (e.g., \"Breeze Dark\")</li> </ul>"},{"location":"theme-files/#theme-name-normalization","title":"Theme Name Normalization","text":"<p>When searching for themes, the tool uses a normalization strategy to improve matching between different variations of the same theme name. The normalization process:</p> <ol> <li>Converts the name to lowercase</li> <li>Removes all spaces</li> <li>Removes all hyphens</li> </ol> <p>For example, these would all match the same normalized theme \"breezedark\":</p> <ul> <li>\"Breeze Dark\"</li> <li>\"breeze-dark\"</li> <li> <p>\"BreezeDark\"</p> </li> <li> <p>Plugin information</p> </li> </ul>"},{"location":"theme-files/#example-metadatadesktop","title":"Example metadata.desktop","text":"<pre><code>[Desktop Entry]\nName=Breeze Dark\nComment=KDE Plasma Theme\nX-KDE-PluginInfo-Author=KDE Visual Design Group\nX-KDE-PluginInfo-Email=plasma-devel@kde.org\nX-KDE-PluginInfo-Name=breeze-dark\nX-KDE-PluginInfo-Version=5.0\nX-KDE-PluginInfo-Website=https://plasma.kde.org\nX-Plasma-API=5.0\n\n[KDE Color Scheme]\nActiveBackground=49,54,59\nActiveForeground=239,240,241\n...\n</code></pre>"},{"location":"theme-files/#color-files","title":"Color Files","text":"<p>Color files (<code>.colors</code> files) are INI-format files that define color schemes for the KDE environment. They contain sections like:</p> <ul> <li><code>[Colors:View]</code> - Colors for view backgrounds and text</li> <li><code>[Colors:Window]</code> - Colors for window elements</li> <li><code>[Colors:Button]</code> - Colors for buttons</li> <li><code>[Colors:Selection]</code> - Colors for selected items</li> <li><code>[Colors:Tooltip]</code> - Colors for tooltips</li> <li><code>[WM]</code> - Colors for window manager elements</li> </ul>"},{"location":"theme-files/#example-color-file-section","title":"Example color file section","text":"<pre><code>[Colors:View]\nBackgroundAlternate=71,80,87\nBackgroundNormal=49,54,59\nDecorationFocus=61,174,233\nDecorationHover=61,174,233\nForegroundActive=61,174,233\n...\n</code></pre>"},{"location":"theme-files/#theme-inheritance","title":"Theme Inheritance","text":"<p>Themes can inherit from other themes using the <code>X-KDE-PluginInfo-Name</code> property. When a theme inherits from another, missing color values will be taken from the parent theme.</p>"},{"location":"theme-files/#theme-discovery-process","title":"Theme Discovery Process","text":"<p>The <code>kde-colors</code> tool discovers themes through the following process:</p> <ol> <li>Collect all search paths (user and system)</li> <li>For each path, check if it's a theme directory</li> <li>If not, recursively search its subdirectories for theme directories</li> <li>Build a mapping of theme names to their file system locations</li> <li>Resolve any theme inheritance</li> </ol>"},{"location":"user-guide/","title":"KDE Theme Colors - User Guide","text":"<p>KDE Theme Colors is a command-line tool that extracts color schemes from KDE Plasma desktop themes. This guide explains how to use the CLI, including all available commands, options, and output formats.</p>"},{"location":"user-guide/#installation","title":"Installation","text":"<pre><code>pip install kde-colors\n</code></pre>"},{"location":"user-guide/#basic-usage","title":"Basic Usage","text":"<p>The basic syntax for the KDE Theme Colors CLI is:</p> <pre><code>kde-colors [GLOBAL OPTIONS] COMMAND [COMMAND OPTIONS]\n</code></pre>"},{"location":"user-guide/#global-options","title":"Global Options","text":"<p>These options can be used with any command:</p> Option Description <code>-j</code>, <code>--json</code> Output as JSON instead of text format. <code>-o</code>, <code>--output PATH</code> Write output to the specified file instead of stdout. <code>-v</code>, <code>--verbose</code> Increase verbosity level. Can be specified multiple times for more detail (e.g., <code>-vv</code> for debug level). <code>--version</code> Show the version number and exit. <code>-h</code>, <code>--help</code> Show help message and exit."},{"location":"user-guide/#commands","title":"Commands","text":""},{"location":"user-guide/#list-command","title":"List Command","text":"<p>Lists all available KDE themes installed on the system.</p> <pre><code>kde-colors list [OPTIONS]\n</code></pre>"},{"location":"user-guide/#list-options","title":"List Options","text":"<p>The List command uses the global options described above.</p>"},{"location":"user-guide/#list-example","title":"List Example","text":"<pre><code># List all themes in text format (default)\nkde-colors list\n\n# List all themes in JSON format\nkde-colors list --json\n\n# Save the list of themes to a file in JSON format\nkde-colors list --json --output themes.json\n</code></pre>"},{"location":"user-guide/#list-output","title":"List Output","text":"<p>Text Format:</p> <pre><code>Available desktop themes (current theme marked with *):\n  oxygen\n* breeze-dark\n  kubuntu\n  default\n  breeze-light\n</code></pre> <p>JSON Format:</p> <pre><code>{\n  \"current_theme\": \"Breeze\",\n  \"themes\": [\n    {\n      \"name\": \"Breeze\",\n      \"display_name\": \"Breeze\",\n      \"description\": \"Default KDE theme\"\n    },\n    {\n      \"name\": \"BreezeDark\",\n      \"display_name\": \"Breeze Dark\",\n      \"description\": \"Dark version of Breeze\"\n    },\n    ...\n  ]\n}\n</code></pre>"},{"location":"user-guide/#paths-command","title":"Paths Command","text":"<p>Shows the system paths where KDE searches for theme files.</p> <pre><code>kde-colors paths [OPTIONS]\n</code></pre>"},{"location":"user-guide/#paths-options","title":"Paths Options","text":"<p>The Paths command uses the global options described above.</p>"},{"location":"user-guide/#paths-example","title":"Paths Example","text":"<pre><code># View theme paths in text format (default)\nkde-colors paths\n\n# View theme paths in JSON format\nkde-colors paths --json\n\n# Save theme paths to a file in JSON format\nkde-colors paths --json --output paths.json\n</code></pre>"},{"location":"user-guide/#paths-output","title":"Paths Output","text":"<p>Text Format:</p> <pre><code>KDE Theme Search Paths:\n- System-wide: /usr/share/plasma/desktoptheme\n- User-specific: /home/username/.local/share/plasma/desktoptheme\n...\n</code></pre> <p>JSON Format:</p> <pre><code>{\n  \"theme_paths\": [\n    {\n      \"type\": \"system\",\n      \"path\": \"/usr/share/plasma/desktoptheme\"\n    },\n    {\n      \"type\": \"user\",\n      \"path\": \"/home/username/.local/share/plasma/desktoptheme\"\n    },\n    ...\n  ]\n}\n</code></pre>"},{"location":"user-guide/#theme-command","title":"Theme Command","text":"<p>Extracts colors from the specified KDE theme. If no theme name is provided, information about the current theme is displayed.</p> <pre><code>kde-colors theme [THEME_NAME] [OPTIONS]\n</code></pre>"},{"location":"user-guide/#theme-arguments","title":"Theme Arguments","text":"Argument Description <code>THEME_NAME</code> (Optional) Name of the theme to extract colors from. If not specified, the current theme will be used."},{"location":"user-guide/#theme-options","title":"Theme Options","text":"<p>The Theme command uses the global options described above.</p>"},{"location":"user-guide/#theme-example","title":"Theme Example","text":"<pre><code># Extract colors from the Breeze theme in text format (default)\nkde-colors theme Breeze\n\n# Extract colors from the Breeze theme in JSON format\nkde-colors theme Breeze --json\n\n# Extract colors from the Breeze Dark theme and save as JSON\nkde-colors theme \"Breeze Dark\" --json --output breeze-dark-colors.json\n\n# Extract colors from the current theme\nkde-colors theme\n</code></pre>"},{"location":"user-guide/#theme-output","title":"Theme Output","text":"<p>Text Format:</p> <pre><code>Theme: Breeze (Breeze)\nAuthor: KDE Visual Design Group\nVersion: 1.0\nDescription: KDE's default theme\nPath: /usr/share/plasma/desktoptheme/Breeze\n\nColors:\n  [Colors:View]\n    BackgroundNormal: #fcfcfc\n    BackgroundAlternate: #eff0f1\n    ForegroundNormal: #232629\n    ForegroundInactive: #7f8c8d\n    ...\n\n  [Colors:Window]\n    BackgroundNormal: #eff0f1\n    BackgroundAlternate: #e3e5e7\n    ...\n</code></pre> <p>JSON Format:</p> <pre><code>{\n  \"theme\": {\n    \"name\": \"Breeze\",\n    \"display_name\": \"Breeze\",\n    \"author\": \"KDE Visual Design Group\",\n    \"version\": \"1.0\",\n    \"description\": \"KDE's default theme\",\n    \"path\": \"/usr/share/plasma/desktoptheme/Breeze\"\n  },\n  \"colors\": {\n    \"Colors:View\": {\n      \"BackgroundNormal\": \"#fcfcfc\",\n      \"BackgroundAlternate\": \"#eff0f1\",\n      \"ForegroundNormal\": \"#232629\",\n      \"ForegroundInactive\": \"#7f8c8d\"\n    },\n    \"Colors:Window\": {\n      \"BackgroundNormal\": \"#eff0f1\",\n      \"BackgroundAlternate\": \"#e3e5e7\"\n    },\n    ...\n  }\n}\n</code></pre>"},{"location":"user-guide/#exit-codes","title":"Exit Codes","text":"<p>The CLI uses the following exit codes to indicate the result of the operation:</p> Code Description 0 Success 1 General error 2 Invalid arguments 3 Theme not found 4 I/O error"},{"location":"user-guide/#examples","title":"Examples","text":""},{"location":"user-guide/#extract-colors-from-current-theme","title":"Extract Colors from Current Theme","text":"<pre><code>kde-colors theme current\n</code></pre>"},{"location":"user-guide/#find-the-current-theme","title":"Find the Current Theme","text":"<pre><code>kde-colors list --format text | grep \"(current)\"\n</code></pre>"},{"location":"user-guide/#extract-colors-and-format-with-jq","title":"Extract Colors and Format with jq","text":"<pre><code>kde-colors theme Breeze | jq '.colors.\"Colors:View\"'\n</code></pre>"},{"location":"user-guide/#list-all-dark-themes","title":"List All Dark Themes","text":"<pre><code>kde-colors list | jq '.themes[] | select(.name | contains(\"Dark\"))'\n</code></pre>"},{"location":"user-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/#common-issues","title":"Common Issues","text":"<ol> <li>Theme not found</li> <li>Check if the theme name is correct (use <code>kde-colors list</code> to verify)</li> <li>Theme names are case-sensitive</li> <li> <p>Use quotes for theme names with spaces: <code>kde-colors theme \"Breeze Dark\"</code></p> </li> <li> <p>Permission errors</p> </li> <li>Ensure you have read access to KDE theme directories</li> <li> <p>For writing output files, ensure you have write permission to the target directory</p> </li> <li> <p>Invalid output format</p> </li> <li>Only <code>text</code> and <code>json</code> formats are supported</li> <li>Check for typos in the format option</li> </ol> <p>If you encounter any issues, increase verbosity with <code>-v</code> or <code>-vv</code> to get more information about the error.</p>"},{"location":"project-files/","title":"KDE Colors","text":"<p>A CLI tool that helps you discover, explore, and extract color schemes from KDE Plasma desktop themes.</p> <p> </p>"},{"location":"project-files/#installation","title":"Installation","text":"<pre><code>pip install kde-colors\n</code></pre>"},{"location":"project-files/#usage","title":"Usage","text":"<p>KDE Colors offers several commands to help you discover and explore themes in your KDE Plasma desktop environment:</p>"},{"location":"project-files/#list-available-themes","title":"List Available Themes","text":"<p>View all available KDE themes on your system:</p> <pre><code>kde-colors list\n</code></pre> <p>Output as JSON:</p> <pre><code>kde-colors list --json\n</code></pre> <p>Save output to a file:</p> <pre><code>kde-colors list --output themes.txt\n</code></pre>"},{"location":"project-files/#show-theme-color-details","title":"Show Theme Color Details","text":"<p>View details of the currently active theme:</p> <pre><code>kde-colors theme\n</code></pre> <p>View details of a specific theme:</p> <pre><code>kde-colors theme \"Breeze Dark\"\n</code></pre> <p>Output as JSON:</p> <pre><code>kde-colors theme --json\n</code></pre>"},{"location":"project-files/#show-theme-file-paths","title":"Show Theme File Paths","text":"<p>View paths to theme files:</p> <pre><code>kde-colors paths\n</code></pre> <p>Output as JSON:</p> <pre><code>kde-colors paths --json\n</code></pre>"},{"location":"project-files/#license","title":"License","text":"<p>MIT</p>"},{"location":"project-files/DEV-README/","title":"Development","text":""},{"location":"project-files/DEV-README/#local-development-setup","title":"Local Development Setup","text":"<p>This project uses Task for task automation and GitHub Actions for CI/CD.</p>"},{"location":"project-files/DEV-README/#python-version-management","title":"Python Version Management","text":"<p>This project supports multiple Python versions using uv for dependency management. Python versions are configured in two files:</p> <ul> <li><code>.python-versions</code> - List of supported Python versions</li> <li><code>.python-version</code> - Default Python version for development</li> </ul> <p>Each Python version has its own virtual environment (<code>.venv-X.Y</code>), and <code>.venv</code> symlinks to the default version's environment.</p>"},{"location":"project-files/DEV-README/#managing-python-versions","title":"Managing Python Versions","text":"<pre><code># List installed Python versions (* marks default)\ntask python:list-installed\n\n# Add a Python version\ntask python:add -- 3.11\n\n# Set default Python version\ntask python:set-default -- 3.11\n\n# Remove a Python version\ntask python:remove -- 3.11\n</code></pre>"},{"location":"project-files/DEV-README/#setup","title":"Setup","text":"<pre><code>task setup\n</code></pre> <p>This will:</p> <ol> <li>Install all Python versions listed in <code>.python-versions</code></li> <li>Create virtual environments for each Python version</li> <li>Install the package in editable mode with all dependencies</li> <li>Set up pre-commit hooks</li> <li>Create <code>.venv</code> symlink to the default Python version</li> </ol>"},{"location":"project-files/DEV-README/#available-tasks","title":"Available Tasks","text":""},{"location":"project-files/DEV-README/#environment-management","title":"Environment Management","text":"<ul> <li><code>task setup</code> - Set up development environments</li> <li><code>task update:env</code> - Update all virtual environments</li> <li><code>task update:dev-env</code> - Update only default environment</li> <li><code>task upgrade-env</code> - Upgrade all dependencies</li> <li><code>task clean</code> - Clean build artifacts and caches</li> <li><code>task clean:venvs</code> - Remove all virtual environments</li> </ul>"},{"location":"project-files/DEV-README/#testing","title":"Testing","text":"<ul> <li><code>task test</code> - Run tests using default Python version</li> <li><code>task test:coverage</code> - Run tests with coverage report</li> <li><code>task test:pythons</code> - Run tests across all supported Python versions</li> </ul>"},{"location":"project-files/DEV-README/#code-quality","title":"Code Quality","text":"<ul> <li><code>task lint</code> - Run code quality checks (ruff, mypy, pre-commit)</li> <li><code>task format</code> - Format code with ruff</li> <li><code>task metrics</code> - Run code quality metrics (radon)</li> <li><code>task spell</code> - Run codespell checks</li> </ul>"},{"location":"project-files/DEV-README/#documentation","title":"Documentation","text":"<ul> <li><code>task docs</code> - Serve documentation locally</li> <li><code>task docs:build</code> - Build documentation</li> </ul>"},{"location":"project-files/DEV-README/#build-and-publish","title":"Build and Publish","text":"<ul> <li><code>task build</code> - Build package distribution (wheel and sdist)</li> <li><code>task publish:pypi</code> - Publish to PyPI</li> <li><code>task publish:test-pypi</code> - Publish to Test PyPI</li> </ul>"},{"location":"project-files/DEV-README/#cicd","title":"CI/CD","text":"<ul> <li><code>task ci</code> - Run all CI checks (lint, test, coverage, docs, build)</li> </ul> <p>Run <code>task --list-all</code> to see all available tasks with descriptions.</p>"},{"location":"project-files/DEV-README/#continuous-integration","title":"Continuous Integration","text":""},{"location":"project-files/DEV-README/#monitoring-workflow-status","title":"Monitoring Workflow Status","text":"<p>To check the status of GitHub Actions:</p> <ol> <li>Go to your repository on GitHub</li> <li>Click the \"Actions\" tab</li> <li>You'll see a list of all workflow runs, with their status:</li> <li>\u2705 Green check: All jobs passed</li> <li>\u274c Red X: One or more jobs failed</li> <li>\ud83d\udfe1 Yellow dot: Workflow is in progress</li> </ol> <p>You can also:</p> <ul> <li>Click on any workflow run to see detailed job results</li> <li>Click the \"Re-run jobs\" button to retry failed jobs</li> <li>See the status badge in the README: </li> </ul> <p>GitHub Actions will automatically:</p> <ul> <li>Run tests across all supported Python versions</li> <li>Upload coverage reports to Codecov</li> <li>Run code quality checks (ruff, mypy)</li> <li>Run security checks (bandit)</li> <li>Build and test documentation</li> <li>Deploy documentation to GitHub Pages (on main branch)</li> <li>Publish package to PyPI (on release)</li> </ul>"},{"location":"project-files/DEV-README/#setting-up-codecov","title":"Setting up Codecov","text":"<p>To enable coverage reporting to Codecov:</p> <ol> <li>Go to https://app.codecov.io/ and sign in with your GitHub account</li> <li>Add your repository:</li> <li>Go to https://app.codecov.io/gh/royw</li> <li>Click \"Add new repository\"</li> <li>Select \"kde_colors\"</li> <li>Get your Codecov token:</li> <li>Go to repository settings</li> <li>Look for \"Repository Upload Token\"</li> <li>Copy the token value</li> <li>Add the token to GitHub:</li> <li>Go to your repository settings on GitHub</li> <li>Navigate to Settings &gt; Secrets and variables &gt; Actions</li> <li>Click \"New repository secret\"</li> <li>Name: <code>CODECOV_TOKEN</code></li> <li>Value: Paste the token from Codecov</li> <li>Click \"Add secret\"</li> </ol>"},{"location":"project-files/DEV-README/#publishing-to-pypi","title":"Publishing to PyPI","text":""},{"location":"project-files/DEV-README/#setting-up-pypi-publishing","title":"Setting up PyPI Publishing","text":"<p>To enable automatic publishing to PyPI and Test PyPI through GitHub Actions:</p> <ol> <li> <p>Create accounts:</p> </li> <li> <p>Sign up for PyPI: https://pypi.org/account/register/</p> </li> <li> <p>Sign up for Test PyPI: https://test.pypi.org/account/register/</p> </li> <li> <p>Create API tokens:</p> </li> <li> <p>Go to https://pypi.org/manage/account/token/</p> </li> <li>Click \"Add API token\"</li> <li>Set scope to \"Project: kde_colors\"</li> <li>Copy the token value</li> <li> <p>Repeat for Test PyPI at https://test.pypi.org/manage/account/token/</p> </li> <li> <p>Add tokens to GitHub:</p> </li> <li> <p>Go to your repository settings on GitHub</p> </li> <li>Navigate to Settings &gt; Secrets and variables &gt; Actions</li> <li> <p>Add two secrets:</p> <ol> <li><code>PYPI_TOKEN</code> - Your PyPI token</li> <li><code>TEST_PYPI_TOKEN</code> - Your Test PyPI token</li> </ol> </li> </ol>"},{"location":"project-files/DEV-README/#publishing-a-new-version","title":"Publishing a New Version","text":"<p>Once set up, you can publish new versions in two ways:</p> <ol> <li>Manual Publishing (using task)</li> </ol> <pre><code># Update version\ntask version:bump -- patch  # For patch version (0.0.x)\ntask version:bump -- minor  # For minor version (0.x.0)\ntask version:bump -- major  # For major version (x.0.0)\n\n# Create and push tag\ntask version:tag\n\n# Manual publishing if needed\ntask publish:test-pypi  # Publish to Test PyPI\ntask publish:pypi       # Publish to PyPI\n</code></pre> <ol> <li>Automatic Publishing (using GitHub)</li> </ol> <p>Simply create a new release on GitHub:    - Go to your repository's Releases page    - Click \"Create a new release\"    - Choose or create a tag (e.g., v0.1.0)    - Fill in the release title and description    - Click \"Publish release\"</p> <p>The CI/CD workflow will automatically:    - Run all checks (lint, test, coverage)    - Build and verify the package    - Publish to Test PyPI first    - Run test installation from Test PyPI    - Publish to PyPI if tests pass    - Build and deploy documentation    - Create a GitHub release</p>"},{"location":"project-files/DEV-README/#online-documentation","title":"Online Documentation","text":"<p>The documentation is built using MkDocs with the Material theme and mkdocstrings for API documentation.</p> <p>To view the documentation locally:</p> <pre><code>task docs\n</code></pre> <p>Then open http://127.0.0.1:8000 in your browser.</p> <p>The documentation is automatically deployed to GitHub Pages when changes are pushed to the main branch: https://royw.github.io/kde_colors/</p>"},{"location":"reference/","title":"Index","text":"<ul> <li>kde_colors<ul> <li>cli<ul> <li>cli_arg_parser</li> <li>cli_runner</li> </ul> </li> <li>interfaces<ul> <li>environment</li> <li>file_system</li> <li>output_formatter</li> <li>theme_loader</li> <li>xdg</li> </ul> </li> <li>services<ul> <li>environment</li> <li>file_system</li> <li>output_formatter</li> <li>theme_loader</li> <li>xdg</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/kde_colors/","title":"Index","text":""},{"location":"reference/kde_colors/#kde_colors","title":"<code>kde_colors</code>","text":"<p>KDE Colors CLI tool package root.</p> <p>This package provides a command-line interface for exploring and managing KDE Plasma desktop themes. It serves as the entry point for the kde-colors CLI application and organizes functionality into submodules following a clean architecture approach with separate interfaces and implementations.</p> <p>The package allows users to: - List available KDE themes - Show detailed information about specific themes - Display all theme search paths in the system</p>"},{"location":"reference/kde_colors/cli/","title":"Index","text":""},{"location":"reference/kde_colors/cli/#kde_colors.cli","title":"<code>kde_colors.cli</code>","text":""},{"location":"reference/kde_colors/cli/cli_arg_parser/","title":"Cli arg parser","text":""},{"location":"reference/kde_colors/cli/cli_arg_parser/#kde_colors.cli.cli_arg_parser","title":"<code>kde_colors.cli.cli_arg_parser</code>","text":"<p>Command-line argument parsing module.</p> <p>This module defines and handles command-line argument parsing for the KDE Colors CLI tool. It uses the sub-parser pattern from Python's argparse module to implement various commands and their specific arguments.</p> <p>Why this module exists: - Separates argument parsing from command execution logic - Provides a clear definition of the CLI's public interface - Centralizes argument validation and help text</p> <p>How it works: - Creates a main parser with global arguments (--json, --output, etc.) - Defines subparsers for each command (list, theme, paths) - Specifies arguments unique to each command - Returns a parsed argument namespace to be processed by the CLI runner</p> <p>This module serves as the implementation of the user-facing interface described in the user guide documentation. The command structure, options, and argument handling are all defined here according to the CLI specifications.</p>"},{"location":"reference/kde_colors/cli/cli_arg_parser/#kde_colors.cli.cli_arg_parser.create_parser","title":"<code>create_parser()</code>","text":"<p>Creates and configures the command-line argument parser.</p> <p>Returns:</p> Type Description <code>ArgumentParser</code> <p>The configured argument parser with all subparsers and options.</p> Source code in <code>src/kde_colors/cli/cli_arg_parser.py</code> <pre><code>def create_parser() -&gt; argparse.ArgumentParser:\n    \"\"\"\n    Creates and configures the command-line argument parser.\n\n    Returns:\n        The configured argument parser with all subparsers and options.\n    \"\"\"\n    # Create the main parser\n    parser = argparse.ArgumentParser(\n        prog=\"kde-colors\",\n        description=\"CLI tool that extracts color schemes from KDE themes\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n\n    # Add global options\n    parser.add_argument(\n        \"--version\",\n        action=\"version\",\n        version=f\"%(prog)s {get_version()}\",\n    )\n\n    # Create subparsers\n    subparsers = parser.add_subparsers(\n        dest=\"command\",\n        title=\"commands\",\n        description=\"valid commands\",\n        help=\"command help\",\n        required=True,\n    )\n\n    # List command\n    list_parser = subparsers.add_parser(\n        \"list\",\n        help=\"List all available KDE themes installed on the system\",\n        description=\"List all available KDE themes installed on the system\",\n    )\n    _add_global_options(list_parser)\n\n    # Paths command - keeping this from the architecture document\n    paths_parser = subparsers.add_parser(\n        \"paths\",\n        help=\"Show theme search paths\",\n        description=\"Display the paths where KDE themes are searched for\",\n    )\n    _add_global_options(paths_parser)\n\n    # Theme command\n    theme_parser = subparsers.add_parser(\n        \"theme\",\n        help=\"Display theme details\",\n        description=\"Show detailed information about a specific theme\",\n    )\n    theme_parser.add_argument(\n        \"theme_name\",\n        nargs=\"?\",  # Make it optional to support getting the current theme\n        help=\"Name of the theme to display. If not specified, the current theme will be used.\",\n    )\n    _add_global_options(theme_parser)\n\n    return parser\n</code></pre>"},{"location":"reference/kde_colors/cli/cli_arg_parser/#kde_colors.cli.cli_arg_parser.get_version","title":"<code>get_version()</code>","text":"<p>Retrieves the application version.</p> <p>Returns:</p> Type Description <code>str</code> <p>The package version string.</p> Source code in <code>src/kde_colors/cli/cli_arg_parser.py</code> <pre><code>def get_version() -&gt; str:\n    \"\"\"\n    Retrieves the application version.\n\n    Returns:\n        The package version string.\n    \"\"\"\n    try:\n        return importlib.metadata.version(\"kde_colors\")\n    except importlib.metadata.PackageNotFoundError:\n        return \"0.1.0\"  # Default during development\n</code></pre>"},{"location":"reference/kde_colors/cli/cli_arg_parser/#kde_colors.cli.cli_arg_parser.parse_args","title":"<code>parse_args(args=None)</code>","text":"<p>Parses command-line arguments and applies defaults.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str] | None</code> <p>Command-line arguments to parse. If None, uses sys.argv[1:].</p> <code>None</code> <p>Returns:</p> Type Description <code>Namespace</code> <p>Namespace containing the parsed command-line arguments.</p> Source code in <code>src/kde_colors/cli/cli_arg_parser.py</code> <pre><code>def parse_args(args: list[str] | None = None) -&gt; argparse.Namespace:\n    \"\"\"\n    Parses command-line arguments and applies defaults.\n\n    Args:\n        args: Command-line arguments to parse. If None, uses sys.argv[1:].\n\n    Returns:\n        Namespace containing the parsed command-line arguments.\n    \"\"\"\n    parser = create_parser()\n    return parser.parse_args(args)\n</code></pre>"},{"location":"reference/kde_colors/cli/cli_runner/","title":"Cli runner","text":""},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner","title":"<code>kde_colors.cli.cli_runner</code>","text":"<p>CLI command execution module.</p> <p>This module provides the implementation for executing CLI commands based on parsed arguments. It serves as the core orchestrator that connects the user's command line input to the appropriate application logic and service implementations.</p> <p>Why this module exists: - Decouples command execution from argument parsing - Coordinates dependency injection for required services - Manages command execution flow and exit codes - Handles output formatting and redirection</p> <p>How it works: - Creates all required service instances (FileSystem, ThemeLoader, etc.) - Maps command names to handler methods using a dispatch dictionary - Calls the appropriate handler based on the command from parsed arguments - Formats and outputs the results using output formatters - Returns appropriate exit codes to the shell</p> <p>Key Functions: - run_cli(): The main entry point for the application, responsible for instantiating and running the CLIRunner class.   This function is called directly by main.py and serves as the package's console script entry point and a test entry point.</p> <p>This module implements the Command pattern, where each CLI command is handled by a dedicated method that processes arguments and delegates to appropriate services.</p>"},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner.CLIRunner","title":"<code>CLIRunner</code>","text":"<p>Orchestrates the execution of commands.</p> Source code in <code>src/kde_colors/cli/cli_runner.py</code> <pre><code>class CLIRunner:\n    \"\"\"Orchestrates the execution of commands.\"\"\"\n\n    def __init__(\n        self,\n        file_system: FileSystemInterface | None = None,\n        xdg: XDGInterface | None = None,\n        environment: EnvironmentInterface | None = None,\n        theme_loader: ThemeLoaderInterface | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the CLI runner.\"\"\"\n        self.file_system = file_system or StdFileSystem()\n        environment = environment or StdEnvironment()\n        self.xdg = xdg or StdXDG(file_system or StdFileSystem(), environment)\n        self.environment = environment\n        self.theme_loader = theme_loader or ThemeLoader(self.file_system, self.xdg)\n\n    def _setup_logging(self, log_level: str) -&gt; None:\n        # log_level contains the number of -v arguments\n        # log_level = 0 =&gt; warning\n        # log_level = 1 =&gt; info\n        # log_level = 2 =&gt; debug\n        # log_level = 3 =&gt; trace\n        logger.remove()\n        levels = [\"WARNING\", \"INFO\", \"DEBUG\", \"TRACE\"]\n        if int(log_level) &gt;= len(levels):\n            log_level = str(len(levels) - 1)\n        level = levels[int(log_level)]\n        # Add normal logs to stdout\n        logger.add(sys.stdout, level=level, filter=lambda record: record[\"level\"].no &lt; logger.level(\"ERROR\").no)\n        # Add error logs to stderr\n        logger.add(sys.stderr, level=\"ERROR\")\n        logger.info(\"log level: {}\", level)\n\n    def run(self, args: list[str] | None = None) -&gt; int:\n        \"\"\"Run the CLI with the given arguments.\n\n        Args:\n            args: Command line arguments (defaults to sys.argv[1:] if None)\n\n        Returns:\n            Exit code as defined in ExitCode enum\n        \"\"\"\n        try:\n            # Parse the arguments\n            arguments = parse_args(args or sys.argv[1:])\n            self._setup_logging(arguments.log_level)\n            logger.debug(\"arguments: {}\", arguments)\n\n            # Get the output formatter\n            format = \"json\" if arguments.json else \"text\"\n            formatter: OutputFormatterInterface = get_output_formatter(format, arguments.command)\n            logger.debug(\"formatter: {}\", formatter)\n\n            # Get the command handler\n            handlers: dict[str, Callable[[str | None], dict[str, Any]]] = {\n                \"list\": self._cmd_list,\n                \"paths\": self._cmd_paths,\n                \"theme\": self._cmd_theme,\n            }\n            handler = handlers.get(arguments.command)\n            if not handler:\n                # This should not happen if the argument parser is configured correctly\n                error_msg = f\"Unknown command '{arguments.command}'\"\n                logger.error(error_msg)\n                return ExitCode.INVALID_ARGUMENTS\n\n            # Execute the command handler\n            # Only theme command expects theme_name, others don't need it\n            result = handler(arguments.theme_name) if arguments.command == \"theme\" else handler(None)\n\n            # Check if the command handler returned an error\n            if \"error\" in result:\n                logger.error(f\"Error: {result['error']}\")\n                # Ensure exit_code is an int\n                exit_code = result.get(\"exit_code\", ExitCode.GENERAL_ERROR)\n                return int(exit_code)\n\n            # Format and write the result from the command handler\n            return self._write(formatter.format(result), arguments.output)\n\n        except ValueError as e:\n            # Handle expected value errors (e.g., missing theme name)\n            logger.error(f\"Error: {e}\")\n            return ExitCode.INVALID_ARGUMENTS\n\n        except FileNotFoundError as e:\n            # Handle file system errors\n            logger.error(f\"Error: {e}\")\n            return ExitCode.IO_ERROR\n\n        except Exception as e:\n            # Handle unexpected errors\n            logger.error(f\"Error: {e}\")\n            return ExitCode.GENERAL_ERROR\n\n    def _write(self, data: str, output_path: Path | None = None) -&gt; int:\n        \"\"\"Write data to output path or stdout.\n\n        Args:\n            data: The formatted data to write\n            output_path: Optional path to write the data to instead of stdout\n\n        Returns:\n            Exit code as defined in ExitCode enum\n        \"\"\"\n        try:\n            if output_path:\n                # Ensure the parent directory exists\n                output_path.parent.mkdir(parents=True, exist_ok=True)\n                # Write to file\n                logger.info(\"Writing output to file: {}\", output_path)\n                self.file_system.write_text(output_path, data)\n            else:\n                # Write to stdout\n                self.file_system.write_stdout(data)\n            return ExitCode.SUCCESS\n        except Exception as e:\n            logger.error(f\"Error writing output: {e}\")\n            return ExitCode.IO_ERROR\n\n    def _cmd_paths(self, _: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Handle the 'paths' command.\n\n        Returns a dictionary with paths where KDE theme files are located.\n\n        Args:\n            _: Unused theme name parameter (required for handler signature)\n\n        Returns:\n            Dictionary with config and theme file paths\n        \"\"\"\n        config_paths = [self.xdg.xdg_config_home(), *self.xdg.xdg_config_dirs()]\n        theme_paths = [str(path / \"plasma\" / \"desktoptheme\") for path in config_paths]\n        color_scheme_paths = [str(path / \"color-schemes\") for path in config_paths]\n\n        return {\n            \"config_paths\": [str(path) for path in config_paths],\n            \"theme_paths\": theme_paths,\n            \"color_scheme_paths\": color_scheme_paths,\n        }\n\n    def _cmd_list(self, _: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Handle the 'list' command.\n\n        Lists all available themes with names and locations.\n\n        Returns:\n            Dictionary with theme information\n        \"\"\"\n        themes = self.theme_loader.load_themes()\n        current_theme = self.theme_loader.get_current_theme()\n        return {\"current_theme\": current_theme, \"themes\": themes}\n\n    def _cmd_theme(self, theme_name: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"\n        Handle the 'theme' command.\n\n        Shows detailed information about a specific theme including its colors.\n        If no theme name is provided, the current theme will be used.\n\n        Args:\n            theme_name: Name of the theme to display information for (optional)\n\n        Returns:\n            Dictionary with theme details or an error if theme not found\n        \"\"\"\n        # If no theme name provided, use the current theme\n        if not theme_name:\n            current_theme = self.theme_loader.get_current_theme()\n            if not current_theme:\n                return {\"error\": \"No current theme found\", \"exit_code\": ExitCode.THEME_NOT_FOUND}\n            logger.debug(f\"Using current theme: {current_theme}\")\n            theme_name = current_theme\n\n        theme = self.theme_loader.load(theme_name)\n        if not theme:\n            return {\"error\": f\"Theme '{theme_name}' not found\", \"exit_code\": ExitCode.THEME_NOT_FOUND}\n\n        return {\"theme\": theme}\n</code></pre>"},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner.CLIRunner.environment","title":"<code>environment = environment</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner.CLIRunner.file_system","title":"<code>file_system = file_system or StdFileSystem()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner.CLIRunner.theme_loader","title":"<code>theme_loader = theme_loader or ThemeLoader(self.file_system, self.xdg)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner.CLIRunner.xdg","title":"<code>xdg = xdg or StdXDG(file_system or StdFileSystem(), environment)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner.CLIRunner.run","title":"<code>run(args=None)</code>","text":"<p>Run the CLI with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str] | None</code> <p>Command line arguments (defaults to sys.argv[1:] if None)</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Exit code as defined in ExitCode enum</p> Source code in <code>src/kde_colors/cli/cli_runner.py</code> <pre><code>def run(self, args: list[str] | None = None) -&gt; int:\n    \"\"\"Run the CLI with the given arguments.\n\n    Args:\n        args: Command line arguments (defaults to sys.argv[1:] if None)\n\n    Returns:\n        Exit code as defined in ExitCode enum\n    \"\"\"\n    try:\n        # Parse the arguments\n        arguments = parse_args(args or sys.argv[1:])\n        self._setup_logging(arguments.log_level)\n        logger.debug(\"arguments: {}\", arguments)\n\n        # Get the output formatter\n        format = \"json\" if arguments.json else \"text\"\n        formatter: OutputFormatterInterface = get_output_formatter(format, arguments.command)\n        logger.debug(\"formatter: {}\", formatter)\n\n        # Get the command handler\n        handlers: dict[str, Callable[[str | None], dict[str, Any]]] = {\n            \"list\": self._cmd_list,\n            \"paths\": self._cmd_paths,\n            \"theme\": self._cmd_theme,\n        }\n        handler = handlers.get(arguments.command)\n        if not handler:\n            # This should not happen if the argument parser is configured correctly\n            error_msg = f\"Unknown command '{arguments.command}'\"\n            logger.error(error_msg)\n            return ExitCode.INVALID_ARGUMENTS\n\n        # Execute the command handler\n        # Only theme command expects theme_name, others don't need it\n        result = handler(arguments.theme_name) if arguments.command == \"theme\" else handler(None)\n\n        # Check if the command handler returned an error\n        if \"error\" in result:\n            logger.error(f\"Error: {result['error']}\")\n            # Ensure exit_code is an int\n            exit_code = result.get(\"exit_code\", ExitCode.GENERAL_ERROR)\n            return int(exit_code)\n\n        # Format and write the result from the command handler\n        return self._write(formatter.format(result), arguments.output)\n\n    except ValueError as e:\n        # Handle expected value errors (e.g., missing theme name)\n        logger.error(f\"Error: {e}\")\n        return ExitCode.INVALID_ARGUMENTS\n\n    except FileNotFoundError as e:\n        # Handle file system errors\n        logger.error(f\"Error: {e}\")\n        return ExitCode.IO_ERROR\n\n    except Exception as e:\n        # Handle unexpected errors\n        logger.error(f\"Error: {e}\")\n        return ExitCode.GENERAL_ERROR\n</code></pre>"},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner.ExitCode","title":"<code>ExitCode</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Exit codes used by the application.</p> Source code in <code>src/kde_colors/cli/cli_runner.py</code> <pre><code>class ExitCode(IntEnum):\n    \"\"\"Exit codes used by the application.\"\"\"\n\n    SUCCESS = 0\n    GENERAL_ERROR = 1\n    INVALID_ARGUMENTS = 2\n    THEME_NOT_FOUND = 3\n    IO_ERROR = 4\n</code></pre>"},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner.ExitCode.GENERAL_ERROR","title":"<code>GENERAL_ERROR = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner.ExitCode.INVALID_ARGUMENTS","title":"<code>INVALID_ARGUMENTS = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner.ExitCode.IO_ERROR","title":"<code>IO_ERROR = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner.ExitCode.SUCCESS","title":"<code>SUCCESS = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner.ExitCode.THEME_NOT_FOUND","title":"<code>THEME_NOT_FOUND = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/cli/cli_runner/#kde_colors.cli.cli_runner.run_cli","title":"<code>run_cli(args=None, file_system=None, xdg=None, environment=None, theme_loader=None)</code>","text":"<p>Main entry point for the CLI.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str] | None</code> <p>Command line arguments (defaults to sys.argv[1:] if None)</p> <code>None</code> <code>file_system</code> <code>FileSystemInterface | None</code> <p>FileSystem implementation to use</p> <code>None</code> <code>xdg</code> <code>XDGInterface | None</code> <p>XDG implementation to use</p> <code>None</code> <code>environment</code> <code>EnvironmentInterface | None</code> <p>Environment implementation to use</p> <code>None</code> <code>theme_loader</code> <code>ThemeLoaderInterface | None</code> <p>ThemeLoader implementation to use</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Exit code as defined in ExitCode enum</p> Source code in <code>src/kde_colors/cli/cli_runner.py</code> <pre><code>def run_cli(\n    args: list[str] | None = None,\n    file_system: FileSystemInterface | None = None,\n    xdg: XDGInterface | None = None,\n    environment: EnvironmentInterface | None = None,\n    theme_loader: ThemeLoaderInterface | None = None,\n) -&gt; int:\n    \"\"\"Main entry point for the CLI.\n\n    Args:\n        args: Command line arguments (defaults to sys.argv[1:] if None)\n        file_system: FileSystem implementation to use\n        xdg: XDG implementation to use\n        environment: Environment implementation to use\n        theme_loader: ThemeLoader implementation to use\n\n    Returns:\n        Exit code as defined in ExitCode enum\n    \"\"\"\n    return CLIRunner(file_system, xdg, environment, theme_loader).run(args)\n</code></pre>"},{"location":"reference/kde_colors/interfaces/","title":"Index","text":""},{"location":"reference/kde_colors/interfaces/#kde_colors.interfaces","title":"<code>kde_colors.interfaces</code>","text":""},{"location":"reference/kde_colors/interfaces/environment/","title":"Environment","text":""},{"location":"reference/kde_colors/interfaces/environment/#kde_colors.interfaces.environment","title":"<code>kde_colors.interfaces.environment</code>","text":"<p>Environment interface module.</p> <p>This module defines the EnvironmentInterface protocol that establishes the contract for accessing operating system environment variables. It serves as an abstraction layer between the application and the actual environment access mechanisms.</p> <p>Why this interface exists: - Decouples the application from direct OS environment variable access - Enables unit testing by allowing test doubles to replace real environment access - Provides a consistent API for environment operations across the application</p> <p>Implementations of this interface are responsible for: - Retrieving environment variable values from the operating system - Providing fallback values for missing variables - Handling environment-specific paths like the user's home directory</p> <p>This interface is particularly important for the application to locate user-specific configuration directories that may vary based on system environment settings.</p>"},{"location":"reference/kde_colors/interfaces/environment/#kde_colors.interfaces.environment.EnvironmentInterface","title":"<code>EnvironmentInterface</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Environment interface for accessing environment variables.</p> Source code in <code>src/kde_colors/interfaces/environment.py</code> <pre><code>class EnvironmentInterface(Protocol):\n    \"\"\"Environment interface for accessing environment variables.\"\"\"\n\n    def getenv(self, name: str) -&gt; str | None:\n        \"\"\"Get the value of an environment variable.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/environment/#kde_colors.interfaces.environment.EnvironmentInterface.getenv","title":"<code>getenv(name)</code>","text":"<p>Get the value of an environment variable.</p> Source code in <code>src/kde_colors/interfaces/environment.py</code> <pre><code>def getenv(self, name: str) -&gt; str | None:\n    \"\"\"Get the value of an environment variable.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/file_system/","title":"File system","text":""},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system","title":"<code>kde_colors.interfaces.file_system</code>","text":"<p>File system interface module.</p> <p>This module defines the FileSystemInterface protocol that establishes the contract for file system operations used throughout the application. It serves as an abstraction layer between the application logic and the actual file system implementation.</p> <p>Why this interface exists: - Decouples the application from direct file system dependencies - Enables thorough unit testing using test doubles instead of real file system - Provides a consistent API for file operations across the application - Supports the dependency inversion principle of clean architecture</p> <p>Implementations of this interface are responsible for: - Reading and writing text files - Checking if files or directories exist - Creating directories - Listing directory contents - Finding files that match glob patterns - Manipulating paths (absolute paths, joining paths, etc.)</p> <p>The @runtime_checkable decorator allows runtime type checking of objects that implement this protocol through isinstance() checks.</p>"},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system.FileSystemInterface","title":"<code>FileSystemInterface</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Abstract Read-only file system operations injector.</p> Source code in <code>src/kde_colors/interfaces/file_system.py</code> <pre><code>@runtime_checkable\nclass FileSystemInterface(Protocol):\n    \"\"\"Abstract Read-only file system operations injector.\"\"\"\n\n    def read_file(self, path: str) -&gt; str:\n        \"\"\"Read file contents as a string.\"\"\"\n        ...\n\n    def read_text(self, path: Path | str) -&gt; str:\n        \"\"\"Read text content from a file.\n\n        Args:\n            path: Path to the file\n\n        Returns:\n            The contents of the file as a string\n        \"\"\"\n        ...\n\n    def write_text(self, path: Path | str, content: str) -&gt; None:\n        \"\"\"Write text content to a file.\n\n        Args:\n            path: Path to the file\n            content: Text content to write\n        \"\"\"\n        ...\n\n    def write_stdout(self, content: str) -&gt; None:\n        \"\"\"Write content to standard output.\n\n        This abstraction allows for testing output without capturing stdout.\n\n        Args:\n            content: Text content to write to stdout\n        \"\"\"\n        ...\n\n    def exists(self, path: str) -&gt; bool:\n        \"\"\"Check if a path exists (file or directory).\"\"\"\n        ...\n\n    def is_file(self, path: str) -&gt; bool:\n        \"\"\"Check if a path is a file.\"\"\"\n        ...\n\n    def is_dir(self, path: str) -&gt; bool:\n        \"\"\"Check if a path is a directory.\"\"\"\n        ...\n\n    def glob(self, pattern: str) -&gt; list[str]:\n        \"\"\"Find paths matching a pattern.\"\"\"\n        ...\n\n    def walk(self, path: str) -&gt; Iterator[tuple[str, list[str], list[str]]]:\n        \"\"\"Walk a directory tree.\"\"\"\n        ...\n\n    def list_dir(self, path: str) -&gt; list[str]:\n        \"\"\"List all entries in a directory.\"\"\"\n        ...\n\n    def home(self) -&gt; Path:\n        \"\"\"Return the home directory.\"\"\"\n        ...\n\n    def root(self) -&gt; Path:\n        \"\"\"Return the root directory.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system.FileSystemInterface.exists","title":"<code>exists(path)</code>","text":"<p>Check if a path exists (file or directory).</p> Source code in <code>src/kde_colors/interfaces/file_system.py</code> <pre><code>def exists(self, path: str) -&gt; bool:\n    \"\"\"Check if a path exists (file or directory).\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system.FileSystemInterface.glob","title":"<code>glob(pattern)</code>","text":"<p>Find paths matching a pattern.</p> Source code in <code>src/kde_colors/interfaces/file_system.py</code> <pre><code>def glob(self, pattern: str) -&gt; list[str]:\n    \"\"\"Find paths matching a pattern.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system.FileSystemInterface.home","title":"<code>home()</code>","text":"<p>Return the home directory.</p> Source code in <code>src/kde_colors/interfaces/file_system.py</code> <pre><code>def home(self) -&gt; Path:\n    \"\"\"Return the home directory.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system.FileSystemInterface.is_dir","title":"<code>is_dir(path)</code>","text":"<p>Check if a path is a directory.</p> Source code in <code>src/kde_colors/interfaces/file_system.py</code> <pre><code>def is_dir(self, path: str) -&gt; bool:\n    \"\"\"Check if a path is a directory.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system.FileSystemInterface.is_file","title":"<code>is_file(path)</code>","text":"<p>Check if a path is a file.</p> Source code in <code>src/kde_colors/interfaces/file_system.py</code> <pre><code>def is_file(self, path: str) -&gt; bool:\n    \"\"\"Check if a path is a file.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system.FileSystemInterface.list_dir","title":"<code>list_dir(path)</code>","text":"<p>List all entries in a directory.</p> Source code in <code>src/kde_colors/interfaces/file_system.py</code> <pre><code>def list_dir(self, path: str) -&gt; list[str]:\n    \"\"\"List all entries in a directory.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system.FileSystemInterface.read_file","title":"<code>read_file(path)</code>","text":"<p>Read file contents as a string.</p> Source code in <code>src/kde_colors/interfaces/file_system.py</code> <pre><code>def read_file(self, path: str) -&gt; str:\n    \"\"\"Read file contents as a string.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system.FileSystemInterface.read_text","title":"<code>read_text(path)</code>","text":"<p>Read text content from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>Path to the file</p> required <p>Returns:</p> Type Description <code>str</code> <p>The contents of the file as a string</p> Source code in <code>src/kde_colors/interfaces/file_system.py</code> <pre><code>def read_text(self, path: Path | str) -&gt; str:\n    \"\"\"Read text content from a file.\n\n    Args:\n        path: Path to the file\n\n    Returns:\n        The contents of the file as a string\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system.FileSystemInterface.root","title":"<code>root()</code>","text":"<p>Return the root directory.</p> Source code in <code>src/kde_colors/interfaces/file_system.py</code> <pre><code>def root(self) -&gt; Path:\n    \"\"\"Return the root directory.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system.FileSystemInterface.walk","title":"<code>walk(path)</code>","text":"<p>Walk a directory tree.</p> Source code in <code>src/kde_colors/interfaces/file_system.py</code> <pre><code>def walk(self, path: str) -&gt; Iterator[tuple[str, list[str], list[str]]]:\n    \"\"\"Walk a directory tree.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system.FileSystemInterface.write_stdout","title":"<code>write_stdout(content)</code>","text":"<p>Write content to standard output.</p> <p>This abstraction allows for testing output without capturing stdout.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Text content to write to stdout</p> required Source code in <code>src/kde_colors/interfaces/file_system.py</code> <pre><code>def write_stdout(self, content: str) -&gt; None:\n    \"\"\"Write content to standard output.\n\n    This abstraction allows for testing output without capturing stdout.\n\n    Args:\n        content: Text content to write to stdout\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/file_system/#kde_colors.interfaces.file_system.FileSystemInterface.write_text","title":"<code>write_text(path, content)</code>","text":"<p>Write text content to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>Path to the file</p> required <code>content</code> <code>str</code> <p>Text content to write</p> required Source code in <code>src/kde_colors/interfaces/file_system.py</code> <pre><code>def write_text(self, path: Path | str, content: str) -&gt; None:\n    \"\"\"Write text content to a file.\n\n    Args:\n        path: Path to the file\n        content: Text content to write\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/output_formatter/","title":"Output formatter","text":""},{"location":"reference/kde_colors/interfaces/output_formatter/#kde_colors.interfaces.output_formatter","title":"<code>kde_colors.interfaces.output_formatter</code>","text":"<p>Output formatter interface module.</p> <p>This module defines the OutputFormatterInterface protocol that establishes the contract for formatting data into different presentation formats (e.g., text, JSON). It serves as the boundary between the CLI command handlers and the specific output formatting implementations.</p> <p>Why this interface exists: - Separates data processing logic from presentation concerns - Allows multiple output format implementations (text, JSON) with a consistent API - Enables command handlers to remain agnostic about output formatting details - Supports the Single Responsibility Principle by isolating formatting logic</p> <p>Implementations of this interface are responsible for: - Converting internal data structures into user-friendly output formats - Handling specific formatting requirements for different commands (list, theme, paths) - Managing output styles based on user preferences (e.g., human-readable vs. machine-readable)</p> <p>The interface is deliberately minimal with a single method to keep implementations focused and maintain a clean separation of concerns within the application architecture.</p>"},{"location":"reference/kde_colors/interfaces/output_formatter/#kde_colors.interfaces.output_formatter.OutputFormatterInterface","title":"<code>OutputFormatterInterface</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Format theme data into different output formats.</p> Source code in <code>src/kde_colors/interfaces/output_formatter.py</code> <pre><code>class OutputFormatterInterface(Protocol):\n    \"\"\"Format theme data into different output formats.\"\"\"\n\n    def format(self, theme_data: dict[str, Any]) -&gt; str:\n        \"\"\"\n        Format theme data into the desired output format.\n\n        Args:\n            theme_data: The theme data to format\n\n        Returns:\n            The formatted output as a string\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/output_formatter/#kde_colors.interfaces.output_formatter.OutputFormatterInterface.format","title":"<code>format(theme_data)</code>","text":"<p>Format theme data into the desired output format.</p> <p>Parameters:</p> Name Type Description Default <code>theme_data</code> <code>dict[str, Any]</code> <p>The theme data to format</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formatted output as a string</p> Source code in <code>src/kde_colors/interfaces/output_formatter.py</code> <pre><code>def format(self, theme_data: dict[str, Any]) -&gt; str:\n    \"\"\"\n    Format theme data into the desired output format.\n\n    Args:\n        theme_data: The theme data to format\n\n    Returns:\n        The formatted output as a string\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/theme_loader/","title":"Theme loader","text":""},{"location":"reference/kde_colors/interfaces/theme_loader/#kde_colors.interfaces.theme_loader","title":"<code>kde_colors.interfaces.theme_loader</code>","text":"<p>ThemeLoader interface module.</p> <p>This module defines the ThemeLoaderInterface protocol that establishes the contract for loading and querying KDE Plasma themes. It serves as the boundary between the CLI commands and the underlying theme implementation details.</p> <p>Why this interface exists: - Enforces a consistent API for accessing theme data - Allows alternative implementations for testing or different backends - Decouples theme discovery/loading logic from CLI command handlers</p> <p>Implementations of this interface are responsible for: - Finding all available KDE themes in the system - Retrieving the currently active theme - Loading detailed theme information (colors, metadata) - Parsing theme files and color values</p> <p>CLI commands interact only with this interface, not directly with any specific implementation, following the dependency inversion principle of clean architecture.</p>"},{"location":"reference/kde_colors/interfaces/theme_loader/#kde_colors.interfaces.theme_loader.ThemeLoaderInterface","title":"<code>ThemeLoaderInterface</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Load and query KDE themes using XDG and FileSystem Interfaces.</p> Source code in <code>src/kde_colors/interfaces/theme_loader.py</code> <pre><code>class ThemeLoaderInterface(Protocol):\n    \"\"\"Load and query KDE themes using XDG and FileSystem Interfaces.\"\"\"\n\n    def load(self, theme_name: str) -&gt; Any | None:\n        \"\"\"\n        Load a theme from the given theme name.\n\n        Args:\n            theme_name: Name of the theme to load\n\n        Returns:\n            Theme data dictionary or None if not found\n        \"\"\"\n        ...\n\n    def load_themes(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Load all available themes.\n\n        Returns:\n            A dictionary of theme information with structure:\n            {\n                \"Theme Name\": {\n                    \"Name\": \"Theme Name\",\n                    \"Id\": \"theme-name\",\n                    \"Normalized Name\": \"themename\",\n                    \"Package\": \"org.kde.themename.desktop\",\n                    \"Path\": \"/path/to/theme\",\n                    \"Colors\": { ... }\n                },\n                ...\n            }\n        \"\"\"\n        ...\n\n    def get_current_theme(self) -&gt; str | None:\n        \"\"\"\n        Get the current theme name.\n\n        Returns:\n            Current theme name or None if not found\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/theme_loader/#kde_colors.interfaces.theme_loader.ThemeLoaderInterface.get_current_theme","title":"<code>get_current_theme()</code>","text":"<p>Get the current theme name.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>Current theme name or None if not found</p> Source code in <code>src/kde_colors/interfaces/theme_loader.py</code> <pre><code>def get_current_theme(self) -&gt; str | None:\n    \"\"\"\n    Get the current theme name.\n\n    Returns:\n        Current theme name or None if not found\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/theme_loader/#kde_colors.interfaces.theme_loader.ThemeLoaderInterface.load","title":"<code>load(theme_name)</code>","text":"<p>Load a theme from the given theme name.</p> <p>Parameters:</p> Name Type Description Default <code>theme_name</code> <code>str</code> <p>Name of the theme to load</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>Theme data dictionary or None if not found</p> Source code in <code>src/kde_colors/interfaces/theme_loader.py</code> <pre><code>def load(self, theme_name: str) -&gt; Any | None:\n    \"\"\"\n    Load a theme from the given theme name.\n\n    Args:\n        theme_name: Name of the theme to load\n\n    Returns:\n        Theme data dictionary or None if not found\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/theme_loader/#kde_colors.interfaces.theme_loader.ThemeLoaderInterface.load_themes","title":"<code>load_themes()</code>","text":"<p>Load all available themes.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary of theme information with structure:</p> <code>dict[str, Any]</code> <p>{ \"Theme Name\": {     \"Name\": \"Theme Name\",     \"Id\": \"theme-name\",     \"Normalized Name\": \"themename\",     \"Package\": \"org.kde.themename.desktop\",     \"Path\": \"/path/to/theme\",     \"Colors\": { ... } }, ...</p> <code>dict[str, Any]</code> <p>}</p> Source code in <code>src/kde_colors/interfaces/theme_loader.py</code> <pre><code>def load_themes(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Load all available themes.\n\n    Returns:\n        A dictionary of theme information with structure:\n        {\n            \"Theme Name\": {\n                \"Name\": \"Theme Name\",\n                \"Id\": \"theme-name\",\n                \"Normalized Name\": \"themename\",\n                \"Package\": \"org.kde.themename.desktop\",\n                \"Path\": \"/path/to/theme\",\n                \"Colors\": { ... }\n            },\n            ...\n        }\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/xdg/","title":"Xdg","text":""},{"location":"reference/kde_colors/interfaces/xdg/#kde_colors.interfaces.xdg","title":"<code>kde_colors.interfaces.xdg</code>","text":"<p>XDG Base Directory interface module.</p> <p>This module defines the XDGInterface protocol that establishes the contract for accessing XDG Base Directory paths in the system. These paths are used to locate configuration files, themes, and other resources following the XDG specification commonly used in Linux desktop environments.</p> <p>Why this interface exists: - Abstracts XDG path resolution from the rest of the application - Provides a consistent API for accessing standard paths on different systems - Enables testing by allowing path resolution to be replaced with test doubles - Centralizes knowledge of KDE-specific path conventions</p> <p>Implementations of this interface are responsible for: - Resolving user-specific configuration directories - Finding system-wide configuration directories - Locating KDE theme and color scheme directories - Determining standard XDG data and config paths</p> <p>The XDG Base Directory specification is essential for correctly interacting with KDE configuration across different Linux distributions and user environments.</p>"},{"location":"reference/kde_colors/interfaces/xdg/#kde_colors.interfaces.xdg.XDGInterface","title":"<code>XDGInterface</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>XDG Base Directory Specification injector.</p> Source code in <code>src/kde_colors/interfaces/xdg.py</code> <pre><code>class XDGInterface(Protocol):\n    \"\"\"XDG Base Directory Specification injector.\"\"\"\n\n    def xdg_config_dirs(self) -&gt; list[Path]:\n        \"\"\"Return a list of Paths corresponding to XDG_CONFIG_DIRS.\"\"\"\n        ...\n\n    def xdg_config_home(self) -&gt; Path:\n        \"\"\"Return a Path corresponding to XDG_CONFIG_HOME.\"\"\"\n        ...\n\n    def xdg_data_dirs(self) -&gt; list[Path]:\n        \"\"\"Return a list of Paths corresponding to XDG_DATA_DIRS.\"\"\"\n        ...\n\n    def xdg_data_home(self) -&gt; Path:\n        \"\"\"Return a Path corresponding to XDG_DATA_HOME.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/xdg/#kde_colors.interfaces.xdg.XDGInterface.xdg_config_dirs","title":"<code>xdg_config_dirs()</code>","text":"<p>Return a list of Paths corresponding to XDG_CONFIG_DIRS.</p> Source code in <code>src/kde_colors/interfaces/xdg.py</code> <pre><code>def xdg_config_dirs(self) -&gt; list[Path]:\n    \"\"\"Return a list of Paths corresponding to XDG_CONFIG_DIRS.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/xdg/#kde_colors.interfaces.xdg.XDGInterface.xdg_config_home","title":"<code>xdg_config_home()</code>","text":"<p>Return a Path corresponding to XDG_CONFIG_HOME.</p> Source code in <code>src/kde_colors/interfaces/xdg.py</code> <pre><code>def xdg_config_home(self) -&gt; Path:\n    \"\"\"Return a Path corresponding to XDG_CONFIG_HOME.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/xdg/#kde_colors.interfaces.xdg.XDGInterface.xdg_data_dirs","title":"<code>xdg_data_dirs()</code>","text":"<p>Return a list of Paths corresponding to XDG_DATA_DIRS.</p> Source code in <code>src/kde_colors/interfaces/xdg.py</code> <pre><code>def xdg_data_dirs(self) -&gt; list[Path]:\n    \"\"\"Return a list of Paths corresponding to XDG_DATA_DIRS.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/interfaces/xdg/#kde_colors.interfaces.xdg.XDGInterface.xdg_data_home","title":"<code>xdg_data_home()</code>","text":"<p>Return a Path corresponding to XDG_DATA_HOME.</p> Source code in <code>src/kde_colors/interfaces/xdg.py</code> <pre><code>def xdg_data_home(self) -&gt; Path:\n    \"\"\"Return a Path corresponding to XDG_DATA_HOME.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kde_colors/services/","title":"Index","text":""},{"location":"reference/kde_colors/services/#kde_colors.services","title":"<code>kde_colors.services</code>","text":""},{"location":"reference/kde_colors/services/environment/","title":"Environment","text":""},{"location":"reference/kde_colors/services/environment/#kde_colors.services.environment","title":"<code>kde_colors.services.environment</code>","text":"<p>Environment service implementation module.</p> <p>This module provides the concrete implementation (StdEnvironment) of the EnvironmentInterface, responsible for accessing and interacting with operating system environment variables.</p> <p>Why this module exists: - Abstracts direct environment variable access to improve testability - Provides a consistent interface for environment operations - Allows for dependency injection to replace real environment access with test doubles</p> <p>The implementation handles: - Retrieving environment variable values - Providing fallback values for missing environment variables - Getting the current user's home directory</p> <p>This service is particularly important for the application to locate user-specific KDE configuration directories that may vary based on environment settings.</p>"},{"location":"reference/kde_colors/services/environment/#kde_colors.services.environment.StdEnvironment","title":"<code>StdEnvironment</code>","text":"<p>               Bases: <code>EnvironmentInterface</code></p> <p>Abstract environment detection injector that encapsulates environment variables.</p> Source code in <code>src/kde_colors/services/environment.py</code> <pre><code>class StdEnvironment(EnvironmentInterface):\n    \"\"\"Abstract environment detection injector that encapsulates environment variables.\"\"\"\n\n    def getenv(self, name: str, default: str | None = None) -&gt; str | None:\n        \"\"\"\n        Retrieve the value of the environment variable.\n\n        Args:\n            name: The name of the environment variable\n            default: A default value if the variable doesn't exist\n\n        Returns:\n            The value of the environment variable or the default\n        \"\"\"\n        return os.environ.get(name, default)\n</code></pre>"},{"location":"reference/kde_colors/services/environment/#kde_colors.services.environment.StdEnvironment.getenv","title":"<code>getenv(name, default=None)</code>","text":"<p>Retrieve the value of the environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the environment variable</p> required <code>default</code> <code>str | None</code> <p>A default value if the variable doesn't exist</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>The value of the environment variable or the default</p> Source code in <code>src/kde_colors/services/environment.py</code> <pre><code>def getenv(self, name: str, default: str | None = None) -&gt; str | None:\n    \"\"\"\n    Retrieve the value of the environment variable.\n\n    Args:\n        name: The name of the environment variable\n        default: A default value if the variable doesn't exist\n\n    Returns:\n        The value of the environment variable or the default\n    \"\"\"\n    return os.environ.get(name, default)\n</code></pre>"},{"location":"reference/kde_colors/services/file_system/","title":"File system","text":""},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system","title":"<code>kde_colors.services.file_system</code>","text":"<p>File system service implementation module.</p> <p>This module provides the concrete implementation (StdFileSystem) of the FileSystemInterface for interacting with the operating system's file system. It serves as a wrapper around Python's built-in file system operations, providing a clean, testable interface.</p> <p>Why this module exists: - Abstracts direct file system operations to support testing without filesystem access - Provides a consistent interface for all file operations needed by the application - Centralizes file system access logic to reduce code duplication</p> <p>The implementation handles: - Reading and writing text files - Checking if files and directories exist - Creating directories - Listing directory contents - Globbing files based on patterns - Getting absolute and home directory paths</p>"},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system.StdFileSystem","title":"<code>StdFileSystem</code>","text":"<p>               Bases: <code>FileSystemInterface</code></p> <p>Implementation of FileSystemInterface providing file system operations.</p> <p>This service handles all interactions with the file system in a testable way, providing read-only operations to access files and directories.</p> Source code in <code>src/kde_colors/services/file_system.py</code> <pre><code>class StdFileSystem(FileSystemInterface):\n    \"\"\"\n    Implementation of FileSystemInterface providing file system operations.\n\n    This service handles all interactions with the file system in a testable way,\n    providing read-only operations to access files and directories.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the file system implementation.\"\"\"\n\n    def read_file(self, path: str) -&gt; str:\n        \"\"\"\n        Read file contents as a string.\n\n        Args:\n            path: Path to the file\n\n        Returns:\n            The contents of the file as a string\n\n        Raises:\n            FileNotFoundError: If the file does not exist\n            PermissionError: If the file cannot be read due to permissions\n        \"\"\"\n        return Path(path).read_text(encoding=\"utf-8\")\n\n    def read_text(self, path: Path | str) -&gt; str:\n        \"\"\"\n        Read text content from a file.\n\n        Args:\n            path: Path to the file\n\n        Returns:\n            The contents of the file as a string\n\n        Raises:\n            FileNotFoundError: If the file does not exist\n            PermissionError: If the file cannot be read due to permissions\n        \"\"\"\n        # Convert to Path if it's a string\n        file_path = Path(path) if isinstance(path, str) else path\n        return file_path.read_text(encoding=\"utf-8\")\n\n    def write_text(self, path: Path | str, content: str) -&gt; None:\n        \"\"\"\n        Write text content to a file.\n\n        Args:\n            path: Path to the file to write to\n            content: Text content to write to the file\n\n        Raises:\n            OSError: If there is an error writing to the file\n        \"\"\"\n        # Ensure the directory exists\n        path = Path(path)\n        path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Write the content\n        path.write_text(content, encoding=\"utf-8\")\n\n    def write_stdout(self, content: str) -&gt; None:\n        \"\"\"\n        Write content to standard output.\n\n        Args:\n            content: Text content to write to stdout\n        \"\"\"\n        print(content)\n\n    def exists(self, path: str) -&gt; bool:\n        \"\"\"\n        Check if a path exists (file or directory).\n\n        Args:\n            path: Path to check\n\n        Returns:\n            True if the path exists, False otherwise\n        \"\"\"\n        return Path(path).exists()\n\n    def is_file(self, path: str) -&gt; bool:\n        \"\"\"\n        Check if a path is a file.\n\n        Args:\n            path: Path to check\n\n        Returns:\n            True if the path is a file, False otherwise\n        \"\"\"\n        return Path(path).is_file()\n\n    def is_dir(self, path: str) -&gt; bool:\n        \"\"\"\n        Check if a path is a directory.\n\n        Args:\n            path: Path to check\n\n        Returns:\n            True if the path is a directory, False otherwise\n        \"\"\"\n        return Path(path).is_dir()\n\n    def glob(self, pattern: str) -&gt; list[str]:\n        \"\"\"\n        Find paths matching a pattern.\n\n        Args:\n            pattern: Glob pattern to match\n\n        Returns:\n            List of paths that match the pattern\n        \"\"\"\n        # Extract the directory part and pattern part\n        path_obj = Path(pattern)\n        if \"*\" in path_obj.name or \"?\" in path_obj.name:\n            # If the pattern is in the basename\n            return [str(p) for p in path_obj.parent.glob(path_obj.name)]\n        # If no pattern in basename, just glob the entire thing\n        return [str(p) for p in Path().glob(pattern)]\n\n    def walk(self, path: str) -&gt; Iterator[tuple[str, list[str], list[str]]]:\n        \"\"\"\n        Walk a directory tree.\n\n        Args:\n            path: Path to the directory to walk\n\n        Returns:\n            Iterator over (dirpath, dirnames, filenames)\n        \"\"\"\n        return os.walk(path)\n\n    def list_dir(self, path: str) -&gt; list[str]:\n        \"\"\"\n        List all entries in a directory.\n\n        Args:\n            path: Directory to list entries from\n\n        Returns:\n            List of all entries in the directory\n        \"\"\"\n        return [p.name for p in Path(path).iterdir()]\n\n    def home(self) -&gt; Path:\n        \"\"\"\n        Return the home directory.\n\n        Returns:\n            Path to the user's home directory\n        \"\"\"\n        return Path.home()\n\n    def root(self) -&gt; Path:\n        \"\"\"\n        Return the root directory.\n\n        Returns:\n            Path to the root directory (/ on Unix)\n        \"\"\"\n        return Path(\"/\")\n</code></pre>"},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system.StdFileSystem.exists","title":"<code>exists(path)</code>","text":"<p>Check if a path exists (file or directory).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the path exists, False otherwise</p> Source code in <code>src/kde_colors/services/file_system.py</code> <pre><code>def exists(self, path: str) -&gt; bool:\n    \"\"\"\n    Check if a path exists (file or directory).\n\n    Args:\n        path: Path to check\n\n    Returns:\n        True if the path exists, False otherwise\n    \"\"\"\n    return Path(path).exists()\n</code></pre>"},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system.StdFileSystem.glob","title":"<code>glob(pattern)</code>","text":"<p>Find paths matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Glob pattern to match</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of paths that match the pattern</p> Source code in <code>src/kde_colors/services/file_system.py</code> <pre><code>def glob(self, pattern: str) -&gt; list[str]:\n    \"\"\"\n    Find paths matching a pattern.\n\n    Args:\n        pattern: Glob pattern to match\n\n    Returns:\n        List of paths that match the pattern\n    \"\"\"\n    # Extract the directory part and pattern part\n    path_obj = Path(pattern)\n    if \"*\" in path_obj.name or \"?\" in path_obj.name:\n        # If the pattern is in the basename\n        return [str(p) for p in path_obj.parent.glob(path_obj.name)]\n    # If no pattern in basename, just glob the entire thing\n    return [str(p) for p in Path().glob(pattern)]\n</code></pre>"},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system.StdFileSystem.home","title":"<code>home()</code>","text":"<p>Return the home directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the user's home directory</p> Source code in <code>src/kde_colors/services/file_system.py</code> <pre><code>def home(self) -&gt; Path:\n    \"\"\"\n    Return the home directory.\n\n    Returns:\n        Path to the user's home directory\n    \"\"\"\n    return Path.home()\n</code></pre>"},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system.StdFileSystem.is_dir","title":"<code>is_dir(path)</code>","text":"<p>Check if a path is a directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the path is a directory, False otherwise</p> Source code in <code>src/kde_colors/services/file_system.py</code> <pre><code>def is_dir(self, path: str) -&gt; bool:\n    \"\"\"\n    Check if a path is a directory.\n\n    Args:\n        path: Path to check\n\n    Returns:\n        True if the path is a directory, False otherwise\n    \"\"\"\n    return Path(path).is_dir()\n</code></pre>"},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system.StdFileSystem.is_file","title":"<code>is_file(path)</code>","text":"<p>Check if a path is a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the path is a file, False otherwise</p> Source code in <code>src/kde_colors/services/file_system.py</code> <pre><code>def is_file(self, path: str) -&gt; bool:\n    \"\"\"\n    Check if a path is a file.\n\n    Args:\n        path: Path to check\n\n    Returns:\n        True if the path is a file, False otherwise\n    \"\"\"\n    return Path(path).is_file()\n</code></pre>"},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system.StdFileSystem.list_dir","title":"<code>list_dir(path)</code>","text":"<p>List all entries in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Directory to list entries from</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of all entries in the directory</p> Source code in <code>src/kde_colors/services/file_system.py</code> <pre><code>def list_dir(self, path: str) -&gt; list[str]:\n    \"\"\"\n    List all entries in a directory.\n\n    Args:\n        path: Directory to list entries from\n\n    Returns:\n        List of all entries in the directory\n    \"\"\"\n    return [p.name for p in Path(path).iterdir()]\n</code></pre>"},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system.StdFileSystem.read_file","title":"<code>read_file(path)</code>","text":"<p>Read file contents as a string.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the file</p> required <p>Returns:</p> Type Description <code>str</code> <p>The contents of the file as a string</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist</p> <code>PermissionError</code> <p>If the file cannot be read due to permissions</p> Source code in <code>src/kde_colors/services/file_system.py</code> <pre><code>def read_file(self, path: str) -&gt; str:\n    \"\"\"\n    Read file contents as a string.\n\n    Args:\n        path: Path to the file\n\n    Returns:\n        The contents of the file as a string\n\n    Raises:\n        FileNotFoundError: If the file does not exist\n        PermissionError: If the file cannot be read due to permissions\n    \"\"\"\n    return Path(path).read_text(encoding=\"utf-8\")\n</code></pre>"},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system.StdFileSystem.read_text","title":"<code>read_text(path)</code>","text":"<p>Read text content from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>Path to the file</p> required <p>Returns:</p> Type Description <code>str</code> <p>The contents of the file as a string</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist</p> <code>PermissionError</code> <p>If the file cannot be read due to permissions</p> Source code in <code>src/kde_colors/services/file_system.py</code> <pre><code>def read_text(self, path: Path | str) -&gt; str:\n    \"\"\"\n    Read text content from a file.\n\n    Args:\n        path: Path to the file\n\n    Returns:\n        The contents of the file as a string\n\n    Raises:\n        FileNotFoundError: If the file does not exist\n        PermissionError: If the file cannot be read due to permissions\n    \"\"\"\n    # Convert to Path if it's a string\n    file_path = Path(path) if isinstance(path, str) else path\n    return file_path.read_text(encoding=\"utf-8\")\n</code></pre>"},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system.StdFileSystem.root","title":"<code>root()</code>","text":"<p>Return the root directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the root directory (/ on Unix)</p> Source code in <code>src/kde_colors/services/file_system.py</code> <pre><code>def root(self) -&gt; Path:\n    \"\"\"\n    Return the root directory.\n\n    Returns:\n        Path to the root directory (/ on Unix)\n    \"\"\"\n    return Path(\"/\")\n</code></pre>"},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system.StdFileSystem.walk","title":"<code>walk(path)</code>","text":"<p>Walk a directory tree.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the directory to walk</p> required <p>Returns:</p> Type Description <code>Iterator[tuple[str, list[str], list[str]]]</code> <p>Iterator over (dirpath, dirnames, filenames)</p> Source code in <code>src/kde_colors/services/file_system.py</code> <pre><code>def walk(self, path: str) -&gt; Iterator[tuple[str, list[str], list[str]]]:\n    \"\"\"\n    Walk a directory tree.\n\n    Args:\n        path: Path to the directory to walk\n\n    Returns:\n        Iterator over (dirpath, dirnames, filenames)\n    \"\"\"\n    return os.walk(path)\n</code></pre>"},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system.StdFileSystem.write_stdout","title":"<code>write_stdout(content)</code>","text":"<p>Write content to standard output.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Text content to write to stdout</p> required Source code in <code>src/kde_colors/services/file_system.py</code> <pre><code>def write_stdout(self, content: str) -&gt; None:\n    \"\"\"\n    Write content to standard output.\n\n    Args:\n        content: Text content to write to stdout\n    \"\"\"\n    print(content)\n</code></pre>"},{"location":"reference/kde_colors/services/file_system/#kde_colors.services.file_system.StdFileSystem.write_text","title":"<code>write_text(path, content)</code>","text":"<p>Write text content to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>Path to the file to write to</p> required <code>content</code> <code>str</code> <p>Text content to write to the file</p> required <p>Raises:</p> Type Description <code>OSError</code> <p>If there is an error writing to the file</p> Source code in <code>src/kde_colors/services/file_system.py</code> <pre><code>def write_text(self, path: Path | str, content: str) -&gt; None:\n    \"\"\"\n    Write text content to a file.\n\n    Args:\n        path: Path to the file to write to\n        content: Text content to write to the file\n\n    Raises:\n        OSError: If there is an error writing to the file\n    \"\"\"\n    # Ensure the directory exists\n    path = Path(path)\n    path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Write the content\n    path.write_text(content, encoding=\"utf-8\")\n</code></pre>"},{"location":"reference/kde_colors/services/output_formatter/","title":"Output formatter","text":""},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter","title":"<code>kde_colors.services.output_formatter</code>","text":"<p>Output formatter service implementations module.</p> <p>This module provides concrete implementations of the OutputFormatterInterface for different output formats (text and JSON) and CLI commands. It's responsible for formatting data from the application's internal representation into user-friendly output formats.</p> <p>The module contains formatter classes for each command (list, path, theme) and output format combination. This separation allows for specialized formatting logic tailored to each command's unique data structure while maintaining a consistent interface.</p> <p>It also provides a factory function that selects the appropriate formatter based on command name and desired output format, decoupling the CLI runner from formatter implementation details.</p>"},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter.ListJsonOutputFormatter","title":"<code>ListJsonOutputFormatter</code>","text":"<p>               Bases: <code>OutputFormatterInterface</code></p> <p>JSON formatter for the list command output.</p> Source code in <code>src/kde_colors/services/output_formatter.py</code> <pre><code>class ListJsonOutputFormatter(OutputFormatterInterface):\n    \"\"\"JSON formatter for the list command output.\"\"\"\n\n    def __str__(self) -&gt; str:\n        return \"JSON formatter for the list command output\"\n\n    def format(self, data: dict[str, Any]) -&gt; str:\n        \"\"\"Format themes list data into JSON format.\n\n        Example:\n\n        {\n            \"current\": \"oxygen\",\n            \"themes\": [\n                \"oxygen\",\n                \"breeze-dark\",\n                \"breeze-light\",\n                \"kubuntu\",\n                \"default\"\n            ]\n        }\n\n        Args:\n            data: Dictionary containing themes data with 'themes' key\n\n        Returns:\n            JSON formatted string\n        \"\"\"\n        # Extract themes from the data\n        themes_dict = data.get(\"themes\", {})\n\n        # Find the current theme\n        current_theme = None\n        theme_names = []\n\n        for theme_name, theme_info in themes_dict.items():\n            theme_names.append(theme_name)\n            if theme_info.get(\"current\", False):\n                current_theme = theme_name\n\n        # Build the result dictionary\n        result = {\"current\": current_theme, \"themes\": sorted(theme_names)}\n\n        return json.dumps(result, indent=2)\n</code></pre>"},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter.ListJsonOutputFormatter.format","title":"<code>format(data)</code>","text":"<p>Format themes list data into JSON format.</p> <p>Example:</p> <p>{     \"current\": \"oxygen\",     \"themes\": [         \"oxygen\",         \"breeze-dark\",         \"breeze-light\",         \"kubuntu\",         \"default\"     ] }</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary containing themes data with 'themes' key</p> required <p>Returns:</p> Type Description <code>str</code> <p>JSON formatted string</p> Source code in <code>src/kde_colors/services/output_formatter.py</code> <pre><code>def format(self, data: dict[str, Any]) -&gt; str:\n    \"\"\"Format themes list data into JSON format.\n\n    Example:\n\n    {\n        \"current\": \"oxygen\",\n        \"themes\": [\n            \"oxygen\",\n            \"breeze-dark\",\n            \"breeze-light\",\n            \"kubuntu\",\n            \"default\"\n        ]\n    }\n\n    Args:\n        data: Dictionary containing themes data with 'themes' key\n\n    Returns:\n        JSON formatted string\n    \"\"\"\n    # Extract themes from the data\n    themes_dict = data.get(\"themes\", {})\n\n    # Find the current theme\n    current_theme = None\n    theme_names = []\n\n    for theme_name, theme_info in themes_dict.items():\n        theme_names.append(theme_name)\n        if theme_info.get(\"current\", False):\n            current_theme = theme_name\n\n    # Build the result dictionary\n    result = {\"current\": current_theme, \"themes\": sorted(theme_names)}\n\n    return json.dumps(result, indent=2)\n</code></pre>"},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter.ListTextOutputFormatter","title":"<code>ListTextOutputFormatter</code>","text":"<p>               Bases: <code>OutputFormatterInterface</code></p> <p>Text formatter for the list command output.</p> Source code in <code>src/kde_colors/services/output_formatter.py</code> <pre><code>class ListTextOutputFormatter(OutputFormatterInterface):\n    \"\"\"Text formatter for the list command output.\"\"\"\n\n    def __str__(self) -&gt; str:\n        return \"Text formatter for the list command output\"\n\n    def format(self, data: dict[str, Any]) -&gt; str:\n        \"\"\"Format themes list data into human-readable text format.\n\n        Example:\n            Available desktop themes (current theme marked with *):\n              oxygen\n            * breeze-dark\n              kubuntu\n              default\n              breeze-light\n\n        Args:\n            data: Dictionary containing themes data with 'themes' key\n\n        Returns:\n            Formatted text string\n        \"\"\"\n        if not data or \"themes\" not in data:\n            return \"No themes found.\"\n\n        themes = data[\"themes\"]\n        if not themes:\n            return \"No themes found.\"\n\n        result = [\"Available desktop themes (current theme marked with *):\"]\n\n        # Sort themes by name for consistent output\n        sorted_themes = sorted(themes.keys())\n        current_theme = data.get(\"current_theme\", \"\")\n\n        for theme_name in sorted_themes:\n            # Check for current theme in two ways:\n            # 1. theme_name matches current_theme at the root level\n            # 2. theme has a current=True property\n            if (theme_name == current_theme) or (themes[theme_name].get(\"current\", False)):\n                result.append(f\"  * {theme_name}\")\n            else:\n                result.append(f\"  {theme_name}\")\n\n        return \"\\n\".join(result)\n</code></pre>"},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter.ListTextOutputFormatter.format","title":"<code>format(data)</code>","text":"<p>Format themes list data into human-readable text format.</p> Example <p>Available desktop themes (current theme marked with *):   oxygen * breeze-dark   kubuntu   default   breeze-light</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary containing themes data with 'themes' key</p> required <p>Returns:</p> Type Description <code>str</code> <p>Formatted text string</p> Source code in <code>src/kde_colors/services/output_formatter.py</code> <pre><code>def format(self, data: dict[str, Any]) -&gt; str:\n    \"\"\"Format themes list data into human-readable text format.\n\n    Example:\n        Available desktop themes (current theme marked with *):\n          oxygen\n        * breeze-dark\n          kubuntu\n          default\n          breeze-light\n\n    Args:\n        data: Dictionary containing themes data with 'themes' key\n\n    Returns:\n        Formatted text string\n    \"\"\"\n    if not data or \"themes\" not in data:\n        return \"No themes found.\"\n\n    themes = data[\"themes\"]\n    if not themes:\n        return \"No themes found.\"\n\n    result = [\"Available desktop themes (current theme marked with *):\"]\n\n    # Sort themes by name for consistent output\n    sorted_themes = sorted(themes.keys())\n    current_theme = data.get(\"current_theme\", \"\")\n\n    for theme_name in sorted_themes:\n        # Check for current theme in two ways:\n        # 1. theme_name matches current_theme at the root level\n        # 2. theme has a current=True property\n        if (theme_name == current_theme) or (themes[theme_name].get(\"current\", False)):\n            result.append(f\"  * {theme_name}\")\n        else:\n            result.append(f\"  {theme_name}\")\n\n    return \"\\n\".join(result)\n</code></pre>"},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter.PathsJsonOutputFormatter","title":"<code>PathsJsonOutputFormatter</code>","text":"<p>               Bases: <code>OutputFormatterInterface</code></p> <p>JSON formatter for the paths command output.</p> Source code in <code>src/kde_colors/services/output_formatter.py</code> <pre><code>class PathsJsonOutputFormatter(OutputFormatterInterface):\n    \"\"\"JSON formatter for the paths command output.\"\"\"\n\n    def __str__(self) -&gt; str:\n        return \"JSON formatter for the paths command output\"\n\n    def format(self, data: dict[str, Any]) -&gt; str:\n        \"\"\"Format paths data into JSON format.\n\n        Args:\n            data: Dictionary containing paths data\n\n        Returns:\n            JSON formatted string\n        \"\"\"\n        return json.dumps(data, indent=2)\n</code></pre>"},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter.PathsJsonOutputFormatter.format","title":"<code>format(data)</code>","text":"<p>Format paths data into JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary containing paths data</p> required <p>Returns:</p> Type Description <code>str</code> <p>JSON formatted string</p> Source code in <code>src/kde_colors/services/output_formatter.py</code> <pre><code>def format(self, data: dict[str, Any]) -&gt; str:\n    \"\"\"Format paths data into JSON format.\n\n    Args:\n        data: Dictionary containing paths data\n\n    Returns:\n        JSON formatted string\n    \"\"\"\n    return json.dumps(data, indent=2)\n</code></pre>"},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter.PathsTextOutputFormatter","title":"<code>PathsTextOutputFormatter</code>","text":"<p>               Bases: <code>OutputFormatterInterface</code></p> <p>Text formatter for the paths command output.</p> Source code in <code>src/kde_colors/services/output_formatter.py</code> <pre><code>class PathsTextOutputFormatter(OutputFormatterInterface):\n    \"\"\"Text formatter for the paths command output.\"\"\"\n\n    def __str__(self) -&gt; str:\n        return \"Text formatter for the paths command output\"\n\n    def format(self, data: dict[str, Any]) -&gt; str:\n        \"\"\"Format paths data into human-readable text format.\n\n        Example:\n            KDE Theme Search Paths:\n            - Config paths:\n              - /home/username/.config\n              - /etc/xdg\n\n            - Theme paths:\n              - /home/username/.local/share/plasma/desktoptheme\n              - /usr/share/plasma/desktoptheme\n\n            - Color scheme paths:\n              - /home/username/.local/share/color-schemes\n              - /usr/share/color-schemes\n\n        Args:\n            data: Dictionary containing paths data\n\n        Returns:\n            Formatted text string\n        \"\"\"\n        if not data:\n            return \"No path information available.\"\n\n        result = [\"KDE Theme Search Paths:\"]\n\n        # Format config paths\n        config_paths = data.get(\"config_paths\", [])\n        if config_paths:\n            result.append(\"- Config paths:\")\n            for path in config_paths:\n                result.append(f\"  - {path}\")\n            result.append(\"\")\n\n        # Format theme paths\n        theme_paths = data.get(\"theme_paths\", [])\n        if theme_paths:\n            result.append(\"- Theme paths:\")\n            for path in theme_paths:\n                result.append(f\"  - {path}\")\n            result.append(\"\")\n\n        # Format color scheme paths\n        color_scheme_paths = data.get(\"color_scheme_paths\", [])\n        if color_scheme_paths:\n            result.append(\"- Color scheme paths:\")\n            for path in color_scheme_paths:\n                result.append(f\"  - {path}\")\n\n        return \"\\n\".join(result)\n</code></pre>"},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter.PathsTextOutputFormatter.format","title":"<code>format(data)</code>","text":"<p>Format paths data into human-readable text format.</p> Example <p>KDE Theme Search Paths: - Config paths:   - /home/username/.config   - /etc/xdg</p> <ul> <li>Theme paths:</li> <li>/home/username/.local/share/plasma/desktoptheme</li> <li> <p>/usr/share/plasma/desktoptheme</p> </li> <li> <p>Color scheme paths:</p> </li> <li>/home/username/.local/share/color-schemes</li> <li>/usr/share/color-schemes</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary containing paths data</p> required <p>Returns:</p> Type Description <code>str</code> <p>Formatted text string</p> Source code in <code>src/kde_colors/services/output_formatter.py</code> <pre><code>def format(self, data: dict[str, Any]) -&gt; str:\n    \"\"\"Format paths data into human-readable text format.\n\n    Example:\n        KDE Theme Search Paths:\n        - Config paths:\n          - /home/username/.config\n          - /etc/xdg\n\n        - Theme paths:\n          - /home/username/.local/share/plasma/desktoptheme\n          - /usr/share/plasma/desktoptheme\n\n        - Color scheme paths:\n          - /home/username/.local/share/color-schemes\n          - /usr/share/color-schemes\n\n    Args:\n        data: Dictionary containing paths data\n\n    Returns:\n        Formatted text string\n    \"\"\"\n    if not data:\n        return \"No path information available.\"\n\n    result = [\"KDE Theme Search Paths:\"]\n\n    # Format config paths\n    config_paths = data.get(\"config_paths\", [])\n    if config_paths:\n        result.append(\"- Config paths:\")\n        for path in config_paths:\n            result.append(f\"  - {path}\")\n        result.append(\"\")\n\n    # Format theme paths\n    theme_paths = data.get(\"theme_paths\", [])\n    if theme_paths:\n        result.append(\"- Theme paths:\")\n        for path in theme_paths:\n            result.append(f\"  - {path}\")\n        result.append(\"\")\n\n    # Format color scheme paths\n    color_scheme_paths = data.get(\"color_scheme_paths\", [])\n    if color_scheme_paths:\n        result.append(\"- Color scheme paths:\")\n        for path in color_scheme_paths:\n            result.append(f\"  - {path}\")\n\n    return \"\\n\".join(result)\n</code></pre>"},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter.ThemeJsonOutputFormatter","title":"<code>ThemeJsonOutputFormatter</code>","text":"<p>               Bases: <code>OutputFormatterInterface</code></p> <p>JSON formatter for the theme command output.</p> Source code in <code>src/kde_colors/services/output_formatter.py</code> <pre><code>class ThemeJsonOutputFormatter(OutputFormatterInterface):\n    \"\"\"JSON formatter for the theme command output.\"\"\"\n\n    def __str__(self) -&gt; str:\n        return \"JSON formatter for the theme command output\"\n\n    def format(self, data: dict[str, Any]) -&gt; str:\n        \"\"\"Format theme data into JSON format.\n\n        Args:\n            data: Dictionary containing theme data\n\n        Returns:\n            JSON formatted string\n        \"\"\"\n        return json.dumps(data, indent=2)\n</code></pre>"},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter.ThemeJsonOutputFormatter.format","title":"<code>format(data)</code>","text":"<p>Format theme data into JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary containing theme data</p> required <p>Returns:</p> Type Description <code>str</code> <p>JSON formatted string</p> Source code in <code>src/kde_colors/services/output_formatter.py</code> <pre><code>def format(self, data: dict[str, Any]) -&gt; str:\n    \"\"\"Format theme data into JSON format.\n\n    Args:\n        data: Dictionary containing theme data\n\n    Returns:\n        JSON formatted string\n    \"\"\"\n    return json.dumps(data, indent=2)\n</code></pre>"},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter.ThemeTextOutputFormatter","title":"<code>ThemeTextOutputFormatter</code>","text":"<p>               Bases: <code>OutputFormatterInterface</code></p> <p>Text formatter for the theme command output.</p> Source code in <code>src/kde_colors/services/output_formatter.py</code> <pre><code>class ThemeTextOutputFormatter(OutputFormatterInterface):\n    \"\"\"Text formatter for the theme command output.\"\"\"\n\n    def __str__(self) -&gt; str:\n        return \"Text formatter for the theme command output\"\n\n    def format(self, data: dict[str, Any]) -&gt; str:\n        \"\"\"Format theme data into human-readable text format.\n\n        Example:\n            Name: Breeze (Breeze)\n            Id: breeze\n            Package: org.kde.breeze.desktop\n            Path: /usr/share/plasma/desktoptheme/Breeze\n\n            Colors:\n            [Colors:View]\n        Args:\n            data: Theme data dictionary\n\n        Returns:\n            Formatted text representation of theme data\n        \"\"\"\n        if \"error\" in data:\n            return f\"Error: {data['error']}\"\n\n        if not data or \"theme\" not in data:\n            return \"No theme data found.\"\n\n        theme = data[\"theme\"]\n        result = []\n\n        # Format theme header\n        result.extend(self._format_theme_header(theme))\n\n        # Format color sections if present\n        if \"Colors\" in theme:\n            result.extend(self._format_color_sections(theme[\"Colors\"]))\n\n        return \"\\n\".join(result)\n\n    def _format_theme_header(self, theme: dict[str, Any]) -&gt; list[str]:\n        \"\"\"Format basic theme information.\n\n        Args:\n            theme: Theme data dictionary\n\n        Returns:\n            List of formatted lines with theme header information\n        \"\"\"\n        return [\n            f\"Name: {theme.get('Name', 'Unknown')}\",\n            f\"Id: {theme.get('Id', 'Unknown')}\",\n            f\"Package: {theme.get('Package', 'Unknown')}\",\n            f\"Path: {theme.get('Path', 'Unknown')}\",\n        ]\n\n    def _format_color_sections(self, colors: dict[str, Any]) -&gt; list[str]:\n        \"\"\"Format all color sections.\n\n        Args:\n            colors: Dictionary of color sections\n\n        Returns:\n            List of formatted lines for all color sections\n        \"\"\"\n        result = [\"\\nColors:\"]\n\n        # Sort the color sections for consistent output\n        color_sections = sorted(colors.keys())\n\n        for section in color_sections:\n            result.append(f\"[{section}]\")\n\n            if isinstance(colors[section], dict):\n                result.extend(self._format_color_entries(colors[section]))\n                # Add blank line after each section\n                result.append(\"\")\n\n        return result\n\n    def _format_color_entries(self, section_colors: dict[str, Any]) -&gt; list[str]:\n        \"\"\"Format individual color entries within a section.\n\n        Args:\n            section_colors: Dictionary of color entries for a section\n\n        Returns:\n            List of formatted lines for color entries\n        \"\"\"\n        result = []\n\n        # Sort color entries for consistent output\n        color_entries = sorted(section_colors.keys())\n\n        for color_key in color_entries:\n            color_value = section_colors[color_key]\n            result.append(self._format_color_entry(color_key, color_value))\n\n        return result\n\n    def _format_color_entry(self, key: str, value: Any) -&gt; str:\n        \"\"\"Format a single color entry.\n\n        Args:\n            key: Color name/key\n            value: Color value (either RGB list or string)\n\n        Returns:\n            Formatted color entry line\n        \"\"\"\n        # Format RGB values as hex if they're lists of integers\n        if isinstance(value, list) and len(value) == 3:\n            r, g, b = value\n            hex_color = f\"#{r:02x}{g:02x}{b:02x}\"\n            return f\"    {key}: {hex_color} (RGB: {r},{g},{b})\"\n\n        return f\"    {key}: {value}\"\n</code></pre>"},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter.ThemeTextOutputFormatter.format","title":"<code>format(data)</code>","text":"<p>Format theme data into human-readable text format.</p> Example <p>Name: Breeze (Breeze) Id: breeze Package: org.kde.breeze.desktop Path: /usr/share/plasma/desktoptheme/Breeze</p> <p>Colors: [Colors:View]</p> <p>Args:     data: Theme data dictionary</p> <p>Returns:</p> Type Description <code>str</code> <p>Formatted text representation of theme data</p> Source code in <code>src/kde_colors/services/output_formatter.py</code> <pre><code>def format(self, data: dict[str, Any]) -&gt; str:\n    \"\"\"Format theme data into human-readable text format.\n\n    Example:\n        Name: Breeze (Breeze)\n        Id: breeze\n        Package: org.kde.breeze.desktop\n        Path: /usr/share/plasma/desktoptheme/Breeze\n\n        Colors:\n        [Colors:View]\n    Args:\n        data: Theme data dictionary\n\n    Returns:\n        Formatted text representation of theme data\n    \"\"\"\n    if \"error\" in data:\n        return f\"Error: {data['error']}\"\n\n    if not data or \"theme\" not in data:\n        return \"No theme data found.\"\n\n    theme = data[\"theme\"]\n    result = []\n\n    # Format theme header\n    result.extend(self._format_theme_header(theme))\n\n    # Format color sections if present\n    if \"Colors\" in theme:\n        result.extend(self._format_color_sections(theme[\"Colors\"]))\n\n    return \"\\n\".join(result)\n</code></pre>"},{"location":"reference/kde_colors/services/output_formatter/#kde_colors.services.output_formatter.get_output_formatter","title":"<code>get_output_formatter(format, command)</code>","text":"<p>Get the output formatter for the given format.</p> Source code in <code>src/kde_colors/services/output_formatter.py</code> <pre><code>def get_output_formatter(format: str, command: str) -&gt; OutputFormatterInterface:\n    \"\"\"Get the output formatter for the given format.\"\"\"\n    formatters: dict[str, dict[str, OutputFormatterInterface]] = {\n        \"list\": {\"text\": ListTextOutputFormatter(), \"json\": ListJsonOutputFormatter()},\n        \"theme\": {\"text\": ThemeTextOutputFormatter(), \"json\": ThemeJsonOutputFormatter()},\n        \"paths\": {\"text\": PathsTextOutputFormatter(), \"json\": PathsJsonOutputFormatter()},\n    }\n    if command not in formatters:\n        msg = f\"Unknown command: {command}\"\n        raise ValueError(msg)\n\n    if format not in formatters[command]:\n        msg = f\"Unknown format: {format}\"\n        raise ValueError(msg)\n\n    return formatters[command][format]\n</code></pre>"},{"location":"reference/kde_colors/services/theme_loader/","title":"Theme loader","text":""},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader","title":"<code>kde_colors.services.theme_loader</code>","text":"<p>Theme loader service implementation module.</p> <p>This module provides the concrete implementation of the ThemeLoaderInterface responsible for discovering, loading, and parsing KDE Plasma desktop themes from the file system.</p> <p>It handles: - Finding all available themes in standard KDE theme directories - Loading theme metadata and color information from theme files - Parsing color values from various formats (RGB strings, hex codes) - Identifying the currently active theme from KDE configuration</p> <p>The module uses the dependency injection pattern, requiring a FileSystemInterface to perform file operations, making it testable and decoupled from direct file system access. \"<code>cached_property</code> decorators are used to optimize performance by caching expensive file system operations results.</p>"},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader","title":"<code>ThemeLoader</code>","text":"<p>               Bases: <code>ThemeLoaderInterface</code></p> Source code in <code>src/kde_colors/services/theme_loader.py</code> <pre><code>class ThemeLoader(ThemeLoaderInterface):\n    # KDE config file containing the current theme name\n    # Config file names and keys\n    KDEDEFAULTS_PACKAGE_FILE = \"kdedefaults/package\"\n    KDEDEFAULTS_KDEGLOBALS_FILE = \"kdedefaults/kdeglobals\"\n    KDEGLOBALS_FILE = \"kdeglobals\"\n    PLASMA_CONFIG_FILE = \"plasmarc\"\n\n    # Config keys\n    THEME_KEY = \"Theme\"\n    LOOK_AND_FEEL_KEY = \"LookAndFeelPackage\"\n    PLASMA_THEME_CONFIG_KEY = \"Theme\"\n    PLASMA_THEME_NAME_KEY = \"name\"\n\n    def __init__(self, file_system: FileSystemInterface, xdg: XDGInterface) -&gt; None:\n        self.file_system = file_system\n        self.xdg = xdg\n\n    def load(self, theme_name: str) -&gt; Any | None:\n        \"\"\"Load a theme from the given theme name.\"\"\"\n        normalized_theme_name = self._normalize(theme_name)\n        themes = self.load_themes()\n        for theme in themes:\n            if themes[theme][\"Normalized Name\"] == normalized_theme_name:\n                return themes[theme]\n        return None\n\n    @cached_property\n    def _themes_cache(self) -&gt; dict[str, Any]:\n        \"\"\"Cached property for themes to avoid repeated file system access.\"\"\"\n        return self._load_themes_impl()\n\n    def load_themes(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Load all available themes.\n\n        The output dictionary should look like:\n\n        {\n            \"Theme Name\": {\n                \"Name\": \"Theme Name\",\n                \"Id\": \"theme-name\",\n                \"Normalized Name\": \"themename\",\n                \"Package\": \"org.kde.themename.desktop\",\n                \"Path\": \"/usr/share/plasma/desktoptheme/Theme Name\"\n                \"Colors\": {\n                    \"[Colors:View]\": ...\n                }\n            },\n            ...\n        }\n\n        Returns:\n            A dictionary of theme information\n        \"\"\"\n        # Use the cached property but allow for cache refreshing when explicitly called\n        return self._themes_cache\n\n    def _load_themes_impl(self) -&gt; dict[str, Any]:\n        \"\"\"Implementation for theme loading logic.\"\"\"\n        theme_paths = self._get_theme_paths_impl()\n        themes: dict[str, Any] = {}\n        current_theme_name = self.get_current_theme()\n\n        for path in theme_paths:\n            theme_name = path.name\n            normalized_name = self._normalize(theme_name)\n            theme_id = theme_name.lower().replace(\" \", \"-\")\n            package_name = f\"org.kde.{normalized_name}.desktop\"\n\n            # Load colors from the theme directory\n            colors = self._load_theme_colors(path)\n            if not colors:\n                # Skip themes with no colors\n                continue\n\n            # Determine if this is the current theme\n            is_current = current_theme_name and self._normalize(current_theme_name) == normalized_name\n\n            themes[theme_name] = {\n                \"Name\": theme_name,\n                \"Id\": theme_id,\n                \"Normalized Name\": normalized_name,\n                \"Package\": package_name,\n                \"Path\": str(path),\n                \"Colors\": colors,\n                \"current\": is_current,\n            }\n\n        return themes\n\n    def _load_theme_colors(self, theme_path: Path) -&gt; dict[str, Any] | None:\n        \"\"\"\n        Load colors from a theme directory following the hierarchy in color-files.md.\n\n        1. Check for named color scheme files in colors/{scheme_name}.colors\n        2. Check for root colors file in the theme directory\n        3. Check for nested colors file in colors/colors\n        4. Extract from metadata as fallback (not implemented yet)\n\n        Args:\n            theme_path: Path to the theme directory\n\n        Returns:\n            Dictionary with color data or None if no colors found\n        \"\"\"\n        colors_data: dict[str, Any] = {}\n        theme_path_str = str(theme_path)\n\n        # First check for named color scheme files\n        colors_dir = f\"{theme_path_str}/colors\"\n        if self.file_system.exists(colors_dir) and self.file_system.is_dir(colors_dir):\n            try:\n                color_files = self.file_system.glob(f\"{colors_dir}/*.colors\")\n                if color_files:\n                    # Use the first .colors file found\n                    colors_data = self._parse_colors_file(color_files[0])\n                    if colors_data:\n                        return colors_data\n            except Exception:\n                logger.debug(\"Failed to parse colors files ({})\", color_files, exc_info=True)\n\n        # Next check for root colors file\n        root_colors_file = f\"{theme_path_str}/colors\"\n        if self.file_system.exists(root_colors_file) and self.file_system.is_file(root_colors_file):\n            colors_data = self._parse_colors_file(root_colors_file)\n            if colors_data:\n                return colors_data\n\n        # Then check for nested colors file\n        nested_colors_file = f\"{colors_dir}/colors\"\n        if self.file_system.exists(nested_colors_file) and self.file_system.is_file(nested_colors_file):\n            colors_data = self._parse_colors_file(nested_colors_file)\n            if colors_data:\n                return colors_data\n\n        # As a last resort, we might try in the future to extract colors from metadata\n        logger.debug(\"Failed to parse colors from theme ({})\", theme_path)\n\n        return None\n\n    def _parse_colors_file(self, colors_file_path: str) -&gt; dict[str, Any]:\n        \"\"\"\n        Parse a KDE colors file (INI format with sections and key-value pairs).\n\n        Args:\n            colors_file_path: Path to the colors file as a string\n\n        Returns:\n            Dictionary with parsed color data\n        \"\"\"\n        try:\n            if not self.file_system.exists(colors_file_path) or not self.file_system.is_file(colors_file_path):\n                return {}\n\n            # Read the file content\n            file_content = self.file_system.read_file(colors_file_path)\n\n            # Parse the INI content using configparser\n            config = configparser.ConfigParser()\n            config.read_string(file_content)\n\n            result: dict[str, Any] = {}\n\n            for section in config.sections():\n                # Type the section data dictionary to accept either strings or lists\n                section_data: dict[str, str | list[int]] = {}\n                for key, value in config[section].items():\n                    parsed_value = self._parse_color_value(value)\n                    section_data[key] = parsed_value\n\n                result[section] = section_data\n\n            return result\n\n        except Exception:\n            # Log the error or handle it appropriately\n            logger.error(\"Failed to parse colors file ({})\", colors_file_path, exc_info=True)\n            return {}\n\n    def _parse_color_value(self, value: str) -&gt; str | list[int]:\n        \"\"\"\n        Parse a color value which could be in several formats:\n        - RGB comma-separated integers: \"255,255,255\"\n        - Hex color: \"#FFFFFF\" or \"#ffffff\"\n        - Named colors or other string values\n\n        Args:\n            value: The color value string to parse\n\n        Returns:\n            Either a list of RGB integers or the original string\n        \"\"\"\n        # Check if it's a comma-separated RGB value\n        if \",\" in value and all(part.strip().isdigit() for part in value.split(\",\")):\n            return [int(part.strip()) for part in value.split(\",\")]\n\n        # Try to parse hex color values\n        if value.startswith(\"#\") and len(value) in (7, 9):  # #RRGGBB or #RRGGBBAA\n            try:\n                # Remove the # prefix\n                hex_value = value[1:]\n\n                # Parse the RGB components\n                if len(hex_value) &gt;= 6:  # At least RGB components\n                    r = int(hex_value[0:2], 16)\n                    g = int(hex_value[2:4], 16)\n                    b = int(hex_value[4:6], 16)\n                    return [r, g, b]\n            except ValueError:\n                # If parsing fails, return the original string\n                logger.debug(\"Failed to parse hex color ({})\", value, exc_info=True)\n\n        # Return the original value if no conversion applied\n        return value\n\n    def _normalize(self, name: str) -&gt; str:\n        \"\"\"Normalize the theme name.\"\"\"\n        return name.lower().replace(\" \", \"\").replace(\"-\", \"\")\n\n    def get_current_theme(self) -&gt; str | None:\n        \"\"\"\n                Get the name of the current active KDE theme.\n\n                Checks configuration files in the following order of precedence:\n        {{ ... }}\n                1. $XDG_CONFIG_HOME/kdedefaults/package\n                2. $XDG_CONFIG_HOME/kdedefaults/kdeglobals\n                3. $XDG_CONFIG_HOME/kdeglobals\n                4. $XDG_CONFIG_HOME/plasmarc\n\n                Returns:\n                    The current theme name or None if not found\n        \"\"\"\n        config_home = self.xdg.xdg_config_home()\n        logger.debug(\"config_home: {}\", config_home)\n\n        # Check configuration files in order of precedence\n        theme_name = self._check_kdedefaults_package(config_home)\n        logger.debug(\"theme_name: {}\", theme_name)\n        if theme_name:\n            return theme_name\n\n        theme_name = self._check_kdedefaults_kdeglobals(config_home)\n        logger.debug(\"theme_name: {}\", theme_name)\n        if theme_name:\n            return theme_name\n\n        theme_name = self._check_kdeglobals(config_home)\n        logger.debug(\"theme_name: {}\", theme_name)\n        if theme_name:\n            return theme_name\n\n        theme_name = self._check_plasmarc([config_home, *self.xdg.xdg_config_dirs()])\n        logger.debug(\"theme_name: {}\", theme_name)\n        if theme_name:\n            return theme_name\n\n        return None\n\n    def _check_kdedefaults_package(self, config_home: Path) -&gt; str | None:\n        \"\"\"Check the kdedefaults/package file for theme name.\"\"\"\n        package_path = config_home / self.KDEDEFAULTS_PACKAGE_FILE\n        if not (self.file_system.exists(str(package_path)) and self.file_system.is_file(str(package_path))):\n            return None\n\n        try:\n            content = self.file_system.read_file(str(package_path))\n            # File contains the package name directly (e.g. org.kde.breezedark.desktop)\n            package_name = content.strip()\n            if not package_name:\n                return None\n\n            return self._extract_theme_from_package(package_name)\n        except Exception:\n            logger.debug(\"Failed to parse package file ({})\", package_path, exc_info=True)\n            return None\n\n    def _check_kdedefaults_kdeglobals(self, config_home: Path) -&gt; str | None:\n        \"\"\"Check the kdedefaults/kdeglobals file for theme name.\"\"\"\n        kdeglobals_path = config_home / self.KDEDEFAULTS_KDEGLOBALS_FILE\n        if not (self.file_system.exists(str(kdeglobals_path)) and self.file_system.is_file(str(kdeglobals_path))):\n            return None\n\n        try:\n            content = self.file_system.read_file(str(kdeglobals_path))\n            config = configparser.ConfigParser()\n            config.read_string(content)\n\n            # Look for Theme key in the [KDE] or [General] section\n            for section in [\"KDE\", \"General\"]:\n                if section in config and self.THEME_KEY in config[section]:\n                    return config[section][self.THEME_KEY]\n            return None\n        except Exception:\n            logger.debug(\"Failed to parse kdedefaults/kdeglobals file ({})\", kdeglobals_path, exc_info=True)\n            return None\n\n    def _check_kdeglobals(self, config_home: Path) -&gt; str | None:\n        \"\"\"Check the kdeglobals file for theme name.\"\"\"\n        kdeglobals_path = config_home / self.KDEGLOBALS_FILE\n        if not (self.file_system.exists(str(kdeglobals_path)) and self.file_system.is_file(str(kdeglobals_path))):\n            return None\n\n        try:\n            content = self.file_system.read_file(str(kdeglobals_path))\n            config = configparser.ConfigParser()\n            config.read_string(content)\n\n            # Look for LookAndFeelPackage key in the [KDE] section\n            if \"KDE\" in config and self.LOOK_AND_FEEL_KEY in config[\"KDE\"]:\n                package_name = config[\"KDE\"][self.LOOK_AND_FEEL_KEY]\n                return self._extract_theme_from_package(package_name)\n            return None\n        except Exception:\n            logger.debug(\"Failed to parse kdeglobals file ({})\", kdeglobals_path, exc_info=True)\n            return None\n\n    def _check_plasmarc(self, config_dirs: list[Path]) -&gt; str | None:\n        \"\"\"Check the plasmarc file for theme name.\"\"\"\n        for config_dir in config_dirs:\n            config_file = config_dir / self.PLASMA_CONFIG_FILE\n            config_path = str(config_file)\n\n            if not (self.file_system.exists(config_path) and self.file_system.is_file(config_path)):\n                continue\n\n            try:\n                content = self.file_system.read_file(config_path)\n                config = configparser.ConfigParser()\n                config.read_string(content)\n\n                # Get the theme name from the config\n                if (\n                    self.PLASMA_THEME_CONFIG_KEY in config\n                    and self.PLASMA_THEME_NAME_KEY in config[self.PLASMA_THEME_CONFIG_KEY]\n                ):\n                    return config[self.PLASMA_THEME_CONFIG_KEY][self.PLASMA_THEME_NAME_KEY]\n            except Exception:\n                logger.debug(\"Failed to parse plasmarc file ({})\", config_path, exc_info=True)\n\n        return None\n\n    def _extract_theme_from_package(self, package_name: str) -&gt; str | None:\n        \"\"\"Extract theme name from package name (e.g., org.kde.breezedark.desktop).\"\"\"\n        theme_parts = package_name.split(\".\")\n        if len(theme_parts) &gt;= 3:\n            # Convert org.kde.breezedark.desktop to breeze-dark\n            theme_name = theme_parts[2].replace(\"desktop\", \"\").strip(\".\")\n            return theme_name.replace(\"dark\", \"-dark\")\n        return None\n\n    def _get_theme_paths_impl(self) -&gt; list[Path]:\n        \"\"\"\n        Get the paths to theme directories that contain color data.\n\n        Searches both XDG config paths and XDG data paths for plasma themes.\n        Only includes directories that exist and contain a 'colors' file.\n\n        Returns:\n            A list of Path objects pointing to valid theme directories\n        \"\"\"\n        theme_paths: list[Path] = []\n\n        # Check XDG config paths first (e.g., ~/.config, /etc/xdg)\n        config_paths = [self.xdg.xdg_config_home(), *self.xdg.xdg_config_dirs()]\n        for config_path in config_paths:\n            plasma_theme_dir_path = str(config_path / \"plasma\" / \"desktoptheme\")\n            if self.file_system.exists(plasma_theme_dir_path) and self.file_system.is_dir(plasma_theme_dir_path):\n                theme_paths.extend(self._find_valid_theme_dirs(Path(plasma_theme_dir_path)))\n\n        # Check XDG data paths next (e.g., ~/.local/share, /usr/share)\n        data_dirs = self.xdg.xdg_data_dirs()\n        data_home = self.xdg.xdg_data_home()\n\n        # Add data_home first since it takes precedence\n        if data_home not in data_dirs:\n            data_dirs.insert(0, data_home)\n\n        for data_dir in data_dirs:\n            plasma_theme_dir_path = f\"{data_dir}/plasma/desktoptheme\"\n            if self.file_system.exists(plasma_theme_dir_path) and self.file_system.is_dir(plasma_theme_dir_path):\n                theme_paths.extend(self._find_valid_theme_dirs(Path(plasma_theme_dir_path)))\n\n        return theme_paths\n\n    def _find_valid_theme_dirs(self, parent_dir: Path) -&gt; list[Path]:\n        \"\"\"\n        Find valid theme directories under the given parent directory.\n\n        A valid theme directory must contain color files in one of the following locations:\n        1. Named color scheme file (colors/{scheme_name}.colors)\n        2. Root colors file (colors in the theme directory root)\n        3. Nested colors file (colors/colors)\n        4. Theme metadata as fallback (not checked here)\n\n        See docs/color-files.md for details.\n\n        Args:\n            parent_dir: The parent directory to search in\n\n        Returns:\n            A list of valid theme directory paths\n        \"\"\"\n        valid_dirs: list[Path] = []\n        parent_dir_str = str(parent_dir)\n\n        try:\n            # List all entries in the parent directory\n            dir_entries = self.file_system.list_dir(parent_dir_str)\n\n            for entry in dir_entries:\n                child_path = f\"{parent_dir_str}/{entry}\"\n\n                # Check if it's a directory\n                if self.file_system.is_dir(child_path):\n                    # Check for root colors file (most common)\n                    root_colors_file = f\"{child_path}/colors\"\n\n                    # Check for nested colors file\n                    nested_colors_dir = f\"{child_path}/colors\"\n                    nested_colors_file = f\"{nested_colors_dir}/colors\"\n\n                    # Check for any *.colors files in the colors directory\n                    has_colors_files = False\n                    if self.file_system.exists(nested_colors_dir) and self.file_system.is_dir(nested_colors_dir):\n                        try:\n                            colors_files = self.file_system.glob(f\"{nested_colors_dir}/*.colors\")\n                            has_colors_files = len(colors_files) &gt; 0\n                        except Exception:\n                            logger.debug(\"Failed to access directory ({})\", child_path, exc_info=True)\n\n                    # If any of the conditions are met, consider it a valid theme directory\n                    if (\n                        (self.file_system.exists(root_colors_file) and self.file_system.is_file(root_colors_file))\n                        or (\n                            self.file_system.exists(nested_colors_file)\n                            and self.file_system.is_file(nested_colors_file)\n                        )\n                        or has_colors_files\n                    ):\n                        valid_dirs.append(Path(child_path))\n\n        except Exception:\n            # Silently skip directories we can't access\n            logger.debug(\"Skipping.  Failed to access directory ({})\", child_path, exc_info=True)\n\n        return valid_dirs\n</code></pre>"},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader.KDEDEFAULTS_KDEGLOBALS_FILE","title":"<code>KDEDEFAULTS_KDEGLOBALS_FILE = 'kdedefaults/kdeglobals'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader.KDEDEFAULTS_PACKAGE_FILE","title":"<code>KDEDEFAULTS_PACKAGE_FILE = 'kdedefaults/package'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader.KDEGLOBALS_FILE","title":"<code>KDEGLOBALS_FILE = 'kdeglobals'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader.LOOK_AND_FEEL_KEY","title":"<code>LOOK_AND_FEEL_KEY = 'LookAndFeelPackage'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader.PLASMA_CONFIG_FILE","title":"<code>PLASMA_CONFIG_FILE = 'plasmarc'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader.PLASMA_THEME_CONFIG_KEY","title":"<code>PLASMA_THEME_CONFIG_KEY = 'Theme'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader.PLASMA_THEME_NAME_KEY","title":"<code>PLASMA_THEME_NAME_KEY = 'name'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader.THEME_KEY","title":"<code>THEME_KEY = 'Theme'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader.file_system","title":"<code>file_system = file_system</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader.xdg","title":"<code>xdg = xdg</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader.get_current_theme","title":"<code>get_current_theme()</code>","text":"<pre><code>    Get the name of the current active KDE theme.\n\n    Checks configuration files in the following order of precedence:\n</code></pre> <p>{{ ... }}         1. $XDG_CONFIG_HOME/kdedefaults/package         2. $XDG_CONFIG_HOME/kdedefaults/kdeglobals         3. $XDG_CONFIG_HOME/kdeglobals         4. $XDG_CONFIG_HOME/plasmarc</p> <pre><code>    Returns:\n        The current theme name or None if not found\n</code></pre> Source code in <code>src/kde_colors/services/theme_loader.py</code> <pre><code>def get_current_theme(self) -&gt; str | None:\n    \"\"\"\n            Get the name of the current active KDE theme.\n\n            Checks configuration files in the following order of precedence:\n    {{ ... }}\n            1. $XDG_CONFIG_HOME/kdedefaults/package\n            2. $XDG_CONFIG_HOME/kdedefaults/kdeglobals\n            3. $XDG_CONFIG_HOME/kdeglobals\n            4. $XDG_CONFIG_HOME/plasmarc\n\n            Returns:\n                The current theme name or None if not found\n    \"\"\"\n    config_home = self.xdg.xdg_config_home()\n    logger.debug(\"config_home: {}\", config_home)\n\n    # Check configuration files in order of precedence\n    theme_name = self._check_kdedefaults_package(config_home)\n    logger.debug(\"theme_name: {}\", theme_name)\n    if theme_name:\n        return theme_name\n\n    theme_name = self._check_kdedefaults_kdeglobals(config_home)\n    logger.debug(\"theme_name: {}\", theme_name)\n    if theme_name:\n        return theme_name\n\n    theme_name = self._check_kdeglobals(config_home)\n    logger.debug(\"theme_name: {}\", theme_name)\n    if theme_name:\n        return theme_name\n\n    theme_name = self._check_plasmarc([config_home, *self.xdg.xdg_config_dirs()])\n    logger.debug(\"theme_name: {}\", theme_name)\n    if theme_name:\n        return theme_name\n\n    return None\n</code></pre>"},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader.load","title":"<code>load(theme_name)</code>","text":"<p>Load a theme from the given theme name.</p> Source code in <code>src/kde_colors/services/theme_loader.py</code> <pre><code>def load(self, theme_name: str) -&gt; Any | None:\n    \"\"\"Load a theme from the given theme name.\"\"\"\n    normalized_theme_name = self._normalize(theme_name)\n    themes = self.load_themes()\n    for theme in themes:\n        if themes[theme][\"Normalized Name\"] == normalized_theme_name:\n            return themes[theme]\n    return None\n</code></pre>"},{"location":"reference/kde_colors/services/theme_loader/#kde_colors.services.theme_loader.ThemeLoader.load_themes","title":"<code>load_themes()</code>","text":"<p>Load all available themes.</p> <p>The output dictionary should look like:</p> <p>{     \"Theme Name\": {         \"Name\": \"Theme Name\",         \"Id\": \"theme-name\",         \"Normalized Name\": \"themename\",         \"Package\": \"org.kde.themename.desktop\",         \"Path\": \"/usr/share/plasma/desktoptheme/Theme Name\"         \"Colors\": {             \"[Colors:View]\": ...         }     },     ... }</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary of theme information</p> Source code in <code>src/kde_colors/services/theme_loader.py</code> <pre><code>def load_themes(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Load all available themes.\n\n    The output dictionary should look like:\n\n    {\n        \"Theme Name\": {\n            \"Name\": \"Theme Name\",\n            \"Id\": \"theme-name\",\n            \"Normalized Name\": \"themename\",\n            \"Package\": \"org.kde.themename.desktop\",\n            \"Path\": \"/usr/share/plasma/desktoptheme/Theme Name\"\n            \"Colors\": {\n                \"[Colors:View]\": ...\n            }\n        },\n        ...\n    }\n\n    Returns:\n        A dictionary of theme information\n    \"\"\"\n    # Use the cached property but allow for cache refreshing when explicitly called\n    return self._themes_cache\n</code></pre>"},{"location":"reference/kde_colors/services/xdg/","title":"Xdg","text":""},{"location":"reference/kde_colors/services/xdg/#kde_colors.services.xdg","title":"<code>kde_colors.services.xdg</code>","text":"<p>XDG directories service implementation module.</p> <p>This module provides the concrete implementation (StdXDG) of the XDGInterface, responsible for determining standard XDG Base Directory paths specific to KDE Plasma.</p> <p>The XDG Base Directory Specification defines locations for configuration, data, and cache files, which are crucial for correctly identifying KDE theme locations across different distributions and configurations.</p> <p>This service exists to: - Abstract platform-specific path resolution from the application logic - Provide consistent access to standard KDE configuration and theme directories - Support testing by allowing path resolution to be replaced with test doubles</p> <p>The implementation determines both system-wide and user-specific paths following the XDG specification, with special handling for KDE-specific directories like plasma themes and color schemes.</p>"},{"location":"reference/kde_colors/services/xdg/#kde_colors.services.xdg.StdXDG","title":"<code>StdXDG</code>","text":"<p>               Bases: <code>XDGInterface</code></p> <p>XDG Base Directory Specification injector using FileSystem and Environment interfaces. Based on xdg_base_dirs.py from the xdg-base-dirs package.</p> Source code in <code>src/kde_colors/services/xdg.py</code> <pre><code>class StdXDG(XDGInterface):\n    \"\"\"\n    XDG Base Directory Specification injector using FileSystem and Environment interfaces.\n    Based on xdg_base_dirs.py from the xdg-base-dirs package.\n    \"\"\"\n\n    def __init__(self, file_system: FileSystemInterface, environment: EnvironmentInterface):\n        self.file_system = file_system\n        self.environment = environment\n\n    # Copyright \u00a9 Scott Stevenson &lt;scott@stevenson.io&gt;\n    #\n    # Permission to use, copy, modify, and/or distribute this software for\n    # any purpose with or without fee is hereby granted, provided that the\n    # above copyright notice and this permission notice appear in all\n    # copies.\n    #\n    # THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\n    # WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\n    # WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE\n    # AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL\n    # DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR\n    # PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n    # TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n    # PERFORMANCE OF THIS SOFTWARE.\n\n    \"\"\"XDG Base Directory Specification variables.\n\n    xdg_cache_home(), xdg_config_home(), xdg_data_home(), and xdg_state_home()\n    return pathlib.Path objects containing the value of the environment variable\n    named XDG_CACHE_HOME, XDG_CONFIG_HOME, XDG_DATA_HOME, and XDG_STATE_HOME\n    respectively, or the default defined in the specification if the environment\n    variable is unset, empty, or contains a relative path rather than absolute\n    path.\n\n    xdg_config_dirs() and xdg_data_dirs() return a list of pathlib.Path\n    objects containing the value, split on colons, of the environment\n    variable named XDG_CONFIG_DIRS and XDG_DATA_DIRS respectively, or the\n    default defined in the specification if the environment variable is\n    unset or empty. Relative paths are ignored, as per the specification.\n\n    xdg_runtime_dir() returns a pathlib.Path object containing the value of\n    the XDG_RUNTIME_DIR environment variable, or None if the environment\n    variable is not set, or contains a relative path rather than absolute path.\n\n    \"\"\"\n\n    def _path_from_env(self, variable: str, default: Path) -&gt; Path:\n        \"\"\"Read an environment variable as a path.\n\n        The environment variable with the specified name is read, and its\n        value returned as a path. If the environment variable is not set, is\n        set to the empty string, or is set to a relative rather than\n        absolute path, the default value is returned.\n\n        Parameters\n        ----------\n        variable : str\n            Name of the environment variable.\n        default : Path\n            Default value.\n\n        Returns\n        -------\n        Path\n            Value from environment or default.\n\n        \"\"\"\n        if (value := self.environment.getenv(variable)) and (path := Path(value)).is_absolute():\n            return path\n        return default\n\n    def _paths_from_env(self, variable: str, default: list[Path]) -&gt; list[Path]:\n        \"\"\"Read an environment variable as a list of paths.\n\n        The environment variable with the specified name is read, and its\n        value split on colons and returned as a list of paths. If the\n        environment variable is not set or empty, the default value is returned.\n        Relative paths are ignored, as per the specification.\n\n        Parameters\n        ----------\n        variable : str\n            Name of the environment variable.\n        default : list[Path]\n            Default value.\n\n        Returns\n        -------\n        list[Path]\n            Value from environment or default.\n        \"\"\"\n        if value := self.environment.getenv(variable):\n            paths = [Path(path) for path in value.split(\":\") if Path(path).is_absolute()]\n            if paths:\n                return paths\n        return default\n\n    def xdg_config_dirs(self) -&gt; list[Path]:\n        \"\"\"Return a list of Paths corresponding to XDG_CONFIG_DIRS.\"\"\"\n        return self._paths_from_env(\"XDG_CONFIG_DIRS\", [self.file_system.root() / \"etc/xdg\"])\n\n    def xdg_config_home(self) -&gt; Path:\n        \"\"\"Return a Path corresponding to XDG_CONFIG_HOME.\"\"\"\n        return self._path_from_env(\"XDG_CONFIG_HOME\", self.file_system.home() / \".config\")\n\n    def xdg_data_dirs(self) -&gt; list[Path]:\n        \"\"\"Return a list of Paths corresponding to XDG_DATA_DIRS.\"\"\"\n        return self._paths_from_env(\n            \"XDG_DATA_DIRS\", [self.file_system.root() / \"usr/local/share/\", self.file_system.root() / \"usr/share/\"]\n        )\n\n    def xdg_data_home(self) -&gt; Path:\n        \"\"\"Return a Path corresponding to XDG_DATA_HOME.\"\"\"\n        return self._path_from_env(\"XDG_DATA_HOME\", self.file_system.home() / \".local\" / \"share\")\n</code></pre>"},{"location":"reference/kde_colors/services/xdg/#kde_colors.services.xdg.StdXDG.environment","title":"<code>environment = environment</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/services/xdg/#kde_colors.services.xdg.StdXDG.file_system","title":"<code>file_system = file_system</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kde_colors/services/xdg/#kde_colors.services.xdg.StdXDG.xdg_config_dirs","title":"<code>xdg_config_dirs()</code>","text":"<p>Return a list of Paths corresponding to XDG_CONFIG_DIRS.</p> Source code in <code>src/kde_colors/services/xdg.py</code> <pre><code>def xdg_config_dirs(self) -&gt; list[Path]:\n    \"\"\"Return a list of Paths corresponding to XDG_CONFIG_DIRS.\"\"\"\n    return self._paths_from_env(\"XDG_CONFIG_DIRS\", [self.file_system.root() / \"etc/xdg\"])\n</code></pre>"},{"location":"reference/kde_colors/services/xdg/#kde_colors.services.xdg.StdXDG.xdg_config_home","title":"<code>xdg_config_home()</code>","text":"<p>Return a Path corresponding to XDG_CONFIG_HOME.</p> Source code in <code>src/kde_colors/services/xdg.py</code> <pre><code>def xdg_config_home(self) -&gt; Path:\n    \"\"\"Return a Path corresponding to XDG_CONFIG_HOME.\"\"\"\n    return self._path_from_env(\"XDG_CONFIG_HOME\", self.file_system.home() / \".config\")\n</code></pre>"},{"location":"reference/kde_colors/services/xdg/#kde_colors.services.xdg.StdXDG.xdg_data_dirs","title":"<code>xdg_data_dirs()</code>","text":"<p>Return a list of Paths corresponding to XDG_DATA_DIRS.</p> Source code in <code>src/kde_colors/services/xdg.py</code> <pre><code>def xdg_data_dirs(self) -&gt; list[Path]:\n    \"\"\"Return a list of Paths corresponding to XDG_DATA_DIRS.\"\"\"\n    return self._paths_from_env(\n        \"XDG_DATA_DIRS\", [self.file_system.root() / \"usr/local/share/\", self.file_system.root() / \"usr/share/\"]\n    )\n</code></pre>"},{"location":"reference/kde_colors/services/xdg/#kde_colors.services.xdg.StdXDG.xdg_data_home","title":"<code>xdg_data_home()</code>","text":"<p>Return a Path corresponding to XDG_DATA_HOME.</p> Source code in <code>src/kde_colors/services/xdg.py</code> <pre><code>def xdg_data_home(self) -&gt; Path:\n    \"\"\"Return a Path corresponding to XDG_DATA_HOME.\"\"\"\n    return self._path_from_env(\"XDG_DATA_HOME\", self.file_system.home() / \".local\" / \"share\")\n</code></pre>"}]}